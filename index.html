<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vocab Adventure - Grade 4 English</title>
    <!-- Load Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Tone.js library for sound effects -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #1f2937, #111827); /* Dark, adventurous background */
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        /* Game Board and Card General Styles */
        .card-container {
            border: 3px solid #b91c1c;
            box-shadow: 0 4px 0 #991b1c; /* ä¿®æ­£é™°å½±é¡è‰²ç‚ºæ·±ç´… */
            transition: transform 0.1s, box-shadow 0.1s, opacity 0.3s;
            cursor: pointer;
            user-select: none;
            height: 100px; 
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-weight: 700;
            border-radius: 0.5rem; 
        }
        
        /* Connect Game (Stage 1) Styles */
        .connect-card {
            background-color: #fca5a5; 
            color: #1f2937;
        }
        .connect-card.selected {
            background-color: #fcd34d; 
            border-color: #d97706;
        }
        .connect-card.matched {
            background-color: #10b981; 
            border-color: #059669;
            box-shadow: none;
            transform: scale(0.9);
            opacity: 0;
            cursor: default;
        }
        .connect-card:active:not(.matched) {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #991b1c;
        }

        /* Memory Game (Stage 2) Styles */
        .memory-card {
            background-color: #fca5a5; 
            box-shadow: 0 8px 0 #991b1c;
            transform: translateY(0);
            backface-visibility: hidden;
            perspective: 1000px;
            height: 120px;
            position: relative;
        }
        .memory-card-back {
            background-color: #3b82f6; 
            color: #fff;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            transform: rotateY(0deg);
            transition: transform 0.5s;
        }
        .memory-card.flipped .memory-card-back {
            transform: rotateY(180deg);
        }
        .memory-card-content {
            transform: rotateY(-180deg);
            transition: transform 0.5s;
            backface-visibility: hidden;
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            padding: 4px;
        }
        .memory-card.flipped .memory-card-content {
            transform: rotateY(0deg);
        }
        .memory-card.matched {
            box-shadow: none;
            background-color: #10b981; 
            transform: scale(0);
            opacity: 0;
            transition: transform 0.5s, opacity 0.5s;
            cursor: default;
        }

        /* Spelling Game (Stage 3 & 4) Styles */
        .letter-block {
            background-color: #3b82f6; 
            border: 3px solid #1e40af;
            color: #fff;
            font-size: 1.5rem;
            width: 50px;
            height: 50px;
            line-height: 50px;
            padding: 0;
            margin: 4px;
            transition: all 0.1s;
        }
        .letter-block.jumbled:hover {
            background-color: #60a5fa;
            transform: translateY(-2px);
        }
        .letter-block.jumbled:active {
            transform: translateY(0px);
            box-shadow: 0 2px 0 #1e40af;
        }
        .letter-block.correct {
            background-color: #10b981;
            border-color: #059669;
            cursor: default;
        }
        .letter-slot {
            background-color: #1f2937; 
            border: 3px dashed #6b7280;
            width: 50px;
            height: 50px;
            line-height: 44px;
            color: #fff;
            font-size: 1.5rem;
            text-transform: lowercase;
        }
        .letter-slot.error {
            background-color: #dc2626; 
            border-color: #991b1c;
            animation: shake 0.5s;
        }

        @keyframes shake {
            0%, 100% {transform: translateX(0);}
            20%, 60% {transform: translateX(-5px);}
            40%, 80% {transform: translateX(5px);}
        }

        /* Stage/Week Button Styles */
        .stage-button {
            background-color: #f59e0b; 
            border: 3px solid #b45309;
            box-shadow: 0 6px 0 #b45309;
            color: #1f2937;
            font-weight: 900;
            padding: 0.5rem 1rem;
            transition: transform 0.1s, box-shadow 0.1s;
        }
        .stage-button:hover:not(:disabled) {
            background-color: #fbbf24;
        }
        .stage-button:active:not(:disabled) {
            transform: translateY(3px);
            box-shadow: 0 3px 0 #b45309;
        }
        .stage-button:disabled {
            background-color: #4b5563;
            border-color: #374151;
            box-shadow: none;
            cursor: not-allowed;
            color: #9ca3af;
        }
        .roblox-title {
            text-shadow: 4px 4px 0 #991b1c;
        }
        /* Shop Styles */
        .shop-item-card {
            background-color: #374151;
            border-color: #6b7280;
        }
        .unlocked-item {
             background-color: #2563eb; 
             border-color: #1e40af;
        }
        .locked-item {
            background-color: #374151;
            opacity: 0.5;
            cursor: default;
        }
        /* Inventory Card Styles */
        .inventory-item-card {
            background-color: #4b5563; 
            border-color: #6b7280;
            box-shadow: 0 2px 0 #374151;
            position: relative;
        }
        .sale-status {
            font-size: 0.7rem;
            font-weight: 900;
            padding: 0.25rem 0.5rem;
            border-radius: 9999px; 
        }

        .facility-card {
             background-color: #1f2937;
             border-color: #4b5563;
        }
        .facility-level-up {
            background-color: #ef4444; 
            border-color: #b91c1c;
            box-shadow: 0 3px 0 #991b1c;
        }
        .facility-max-level {
             background-color: #10b981;
             border-color: #059669;
        }
        .crafting-card {
            background-color: #2d3748; 
            border: 2px solid #6366f1;
            box-shadow: 0 4px 0 #4f46e5;
        }
    </style>
</head>
<body class="p-4 md:p-10">

    <!-- Main Game Container -->
    <div id="game-container" class="w-full max-w-5xl mx-auto p-6 bg-gray-800 rounded-xl shadow-2xl border-4 border-yellow-500">
        
        <!-- Title and Score Display -->
        <div class="flex justify-between items-center mb-4">
            <h1 class="roblox-title text-3xl sm:text-4xl font-extrabold text-yellow-300 flex items-center">
                <span class="text-5xl mr-3 transform -rotate-12">ğŸ’¡</span> Vocab Adventure!
            </h1>
            <div class="flex items-center space-x-4">
                 <div id="level-display" class="bg-blue-600 px-3 py-2 rounded-lg font-bold text-lg text-white shadow-lg border-2 border-blue-800">
                    Level: 1
                </div>
                <div id="score-display" class="bg-yellow-600 px-4 py-2 rounded-lg font-bold text-xl text-gray-900 shadow-lg border-2 border-yellow-800 relative">
                    Coins: 0
                </div>
            </div>
        </div>
        
        <!-- Message Box -->
        <div id="message-box" class="text-center p-3 mb-6 rounded-lg font-bold text-lg bg-red-600 text-white shadow-xl">
            Select a Week to Start Challenges!
        </div>
        
        <!-- Main Navigation -->
        <div id="main-nav" class="flex flex-wrap justify-center gap-4 mb-6">
            <button id="nav-game" class="stage-button rounded-xl" onclick="showView('game')">Vocab Stages</button>
            <button id="nav-shop" class="stage-button rounded-xl" onclick="showView('shop')">My Fast Food Shop ğŸ”</button>
        </div>

        <!-- Game View - Visibility Controlled -->
        <div id="game-view" class="">
            <!-- Week Selector -->
            <div id="week-selector" class="flex flex-wrap justify-center gap-2 sm:gap-4 mb-6">
                <!-- Week buttons generated here -->
            </div>

            <!-- Stage Selector -->
            <div id="stage-selector" class="flex flex-col sm:flex-row justify-center gap-4 mb-8">
                <button id="stage1-button" class="stage-button rounded-xl" onclick="startGame(window.getCurrentWeek(), 1)">
                    Stage 1: Picture Match
                </button>
                <button id="stage2-button" class="stage-button rounded-xl" onclick="startGame(window.getCurrentWeek(), 2)">
                    Stage 2: Keyword Memory
                </button>
                <button id="stage3-button" class="stage-button rounded-xl" onclick="startGame(window.getCurrentWeek(), 3)">
                    Stage 3: Spelling Challenge
                </button>
                <button id="stage4-button" class="stage-button rounded-xl bg-purple-600 border-purple-800 shadow-purple-800" onclick="startGame(window.getCurrentWeek(), 4)">
                    Stage 4: Handwriting Practice
                </button>
            </div>

            <!-- Game Board -->
            <div id="game-board" class="p-4 bg-gray-900 rounded-lg min-h-[300px]">
                <p class="text-center text-xl text-gray-500 pt-16">Please select a Week and a Stage to start!</p>
            </div>
        </div>
        
        <!-- Shop View - Visibility Controlled -->
        <div id="shop-view" class="hidden">
            <div id="shop-content" class="p-4 bg-gray-900 rounded-lg">
                <!-- Shop Content generated here -->
                <div class="text-center mt-8">
                    <button id="reset-progress-button" class="px-3 py-1 rounded-lg" onclick="resetGameProgress()">
                        Reset All Progress (Coins & Level)
                    </button>
                </div>
            </div>
        </div>


        <!-- Copyright Note -->
        <div class="text-center text-sm mt-8 text-gray-400">
            <p>Powered by Gemini Engine v2.5. Challenge for Coins!</p>
        </div>
    </div>

    <script type="module">
        // --- TTS Core Functionality (Used for Stage 3 word reading) ---

        const base64ToArrayBuffer = (base64) => {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        };

        const pcmToWav = (pcm16, sampleRate) => {
            const numChannels = 1;
            const bitsPerSample = 16;
            const byteRate = sampleRate * numChannels * (bitsPerSample / 8);
            const blockAlign = numChannels * (bitsPerSample / 8);
            const buffer = new ArrayBuffer(44 + pcm16.length * 2);
            const view = new DataView(buffer);
            let offset = 0;
            const writeString = (s) => {
                for (let i = 0; i < s.length; i++) {
                    view.setUint8(offset++, s.charCodeAt(i));
                }
            };
            writeString('RIFF');
            view.setUint32(offset, 36 + pcm16.length * 2, true); offset += 4;
            writeString('WAVE');
            writeString('fmt ');
            view.setUint32(offset, 16, true); offset += 4;
            view.setUint16(offset, 1, true); offset += 2;
            view.setUint16(offset, numChannels, true); offset += 2;
            view.setUint32(offset, sampleRate, true); offset += 4;
            view.setUint32(offset, byteRate, true); offset += 4;
            view.setUint16(offset, blockAlign, true); offset += 2;
            view.setUint16(offset, bitsPerSample, true); offset += 2;
            writeString('data');
            view.setUint32(offset, pcm16.length * 2, true); offset += 4;
            for (let i = 0; i < pcm16.length; i++) {
                view.setInt16(offset, pcm16[i], true);
                offset += 2;
            }
            return new Blob([view], { type: 'audio/wav' });
        };

        async function speakWord(word) {
            const messageBox = document.getElementById('message-box');
            
            for (let attempt = 0; attempt < 3; attempt++) {
                try {
                    const payload = {
                        contents: [{
                            parts: [{ text: `Say the English word clearly and slightly fast: ${word}` }] 
                        }],
                        generationConfig: {
                            responseModalities: ["AUDIO"],
                            speechConfig: {
                                voiceConfig: {
                                    prebuiltVoiceConfig: { voiceName: "Puck" }
                                }
                            }
                        },
                        model: "gemini-2.5-flash-preview-tts"
                    };
                    const apiKey = "";
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const result = await response.json();
                    const part = result?.candidates?.[0]?.content?.parts?.[0];
                    const audioData = part?.inlineData?.data;
                    const mimeType = part?.inlineData?.mimeType;

                    if (audioData && mimeType && mimeType.startsWith("audio/")) {
                        const sampleRateMatch = mimeType.match(/rate=(\d+)/);
                        const sampleRate = sampleRateMatch ? parseInt(sampleRateMatch[1], 10) : 16000; 

                        const pcmData = base64ToArrayBuffer(audioData);
                        const pcm16 = new Int16Array(pcmData);
                        const wavBlob = pcmToWav(pcm16, sampleRate);
                        const audioUrl = URL.createObjectURL(wavBlob);

                        const audio = new Audio(audioUrl);
                        audio.play().catch(e => console.error("Audio playback failed:", e));
                        return;
                    } else {
                        throw new Error("Invalid audio data received or missing content.");
                    }
                } catch (error) {
                    if (attempt === 2) {
                         messageBox.textContent = 'ğŸ”Š Audio is unavailable. Continue the challenge!';
                    }
                }
            }
        }

        
        // --- Vocab Data: Week 11 - Week 18 (25 words each) ---
        const vocabData = {
            11: [
                { word: 'memory', concept: 'è¢«è¨˜ä½çš„äº‹', icon: 'ğŸ§ ', keyword: 'something remembered', chinese: 'è¨˜æ†¶' },
                { word: 'tap', concept: 'è¼•è¼•æ•²æ“Š', icon: 'ğŸ‘†', keyword: 'hit something lightly', chinese: 'è¼•æ•²' },
                { word: 'monsoon', concept: 'äºæ´²å¤å­£å¤§é›¨', icon: 'ğŸŒ§ï¸', keyword: 'rains in summer', chinese: 'å­£é¢¨' },
                { word: 'scroll', concept: 'å¤ä»£åœ°åœ–/æ²è»¸', icon: 'ğŸ“œ', keyword: 'long piece of paper', chinese: 'æ²è»¸' },
                { word: 'cushion', concept: 'æŸ”è»Ÿæ–¹å¡Š/é å¢Š', icon: 'ğŸ›‹ï¸', keyword: 'soft object comfortable', chinese: 'é å¢Š' },
                { word: 'possession', concept: 'æ“æœ‰çš„æ±è¥¿', icon: 'ğŸ’', keyword: 'something you own', chinese: 'è²¡ç”¢' },
                { word: 'raindrop', concept: 'å–®ä¸€é›¨æ»´', icon: 'ğŸ’§', keyword: 'single drop of rain', chinese: 'é›¨æ»´' },
                { word: 'foreign', concept: 'ä¸åŒåœ‹å®¶ä¾†çš„', icon: 'ğŸŒ', keyword: 'from a different country', chinese: 'å¤–åœ‹çš„' },
                { word: 'moan', concept: 'æ‚²å‚·/æŠ±æ€¨è‡‰', icon: 'ğŸ˜©', keyword: 'complain low sound', chinese: 'å‘»åŸ' },
                { word: 'willow', concept: 'æŸ³æ¨¹/ç´°é•·çš„æ¨¹', icon: 'ğŸŒ³', keyword: 'type of tree', chinese: 'æŸ³æ¨¹' },
                { word: 'guest', concept: 'è¢«é‚€è«‹çš„äºº', icon: 'ğŸ›ï¸', keyword: 'person invited to stay', chinese: 'å®¢äºº' },
                { word: 'farewell', concept: 'æ®æ‰‹å‘Šåˆ¥', icon: 'ğŸ‘‹', keyword: 'say to a person leaving', chinese: 'å‘Šåˆ¥' },
                { word: 'plump', concept: 'åœ“èƒ–è§’è‰²', icon: 'ğŸ·', keyword: 'a little fat', chinese: 'è±æ»¿çš„' },
                { word: 'hanbok', concept: 'éŸ“åœ‹å‚³çµ±æœè£', icon: 'ğŸ‘˜', keyword: 'traditional Korean dress', chinese: 'éŸ“æœ' },
                { word: 'bap sang', concept: 'éŸ“åœ‹é¤é»/é£Ÿç‰©', icon: 'ğŸš', keyword: 'Korean meal food', chinese: 'éŸ“å¼é¤é»' },
                { word: 'blink', concept: 'é–‰çœ¼é–‹çœ¼å‹•ä½œ', icon: 'ğŸ˜‰', keyword: 'closing and opening eyes', chinese: 'çœ¨çœ¼' },
                { word: 'pastel', concept: 'æ·¡è‰²/æ·ºè‰²', icon: 'ğŸ¨', keyword: 'a pale or light color', chinese: 'æŸ”å’Œè‰²' },
                { word: 'traditional', concept: 'åŸºæ–¼é•·æœŸç¿’æ…£çš„', icon: 'ğŸ•°ï¸', keyword: 'based on a way used long time', chinese: 'å‚³çµ±çš„' },
                { word: 'celebrate', concept: 'æ…¶ç¥é‡è¦äº‹ä»¶', icon: 'ğŸ¥³', keyword: 'do something special enjoyable', chinese: 'æ…¶ç¥' },
                { word: 'ripple', concept: 'å°æ³¢æµªç§»å‹•', icon: 'ğŸŒŠ', keyword: 'to move in small waves', chinese: 'æ¼£æ¼ª' },
                { word: 'sneak', concept: 'å®‰éœåœ°ç§»å‹•', icon: 'ğŸ¤«', keyword: 'move quietly not heard', chinese: 'å·æºœ' },
                { word: 'glum', concept: 'æ‚²å‚·çš„/ç—›è‹¦çš„', icon: 'ğŸ˜”', keyword: 'sad miserable', chinese: 'æ²®å–ªçš„' },
                { word: 'perk up', concept: 'æŒ¯ä½œèµ·ä¾†', icon: 'ğŸ˜„', keyword: 'to cheer up become happier', chinese: 'æŒ¯ä½œ' },
                { word: 'brighten', concept: 'ä½¿å¿ƒæƒ…è®Šå¥½', icon: 'â˜€ï¸', keyword: 'to improve ones mood', chinese: 'ä½¿æ„‰å¿«' },
                { word: 'airport', concept: 'é£›æ©Ÿèµ·é™åœ°', icon: 'âœˆï¸', keyword: 'aircraft take off and land', chinese: 'æ©Ÿå ´' },
            ],
            12: [
                { word: 'instruct', concept: 'è€å¸«æŒ‡å°', icon: 'ğŸ§‘â€ğŸ«', keyword: 'to teach give command', chinese: 'æŒ‡å°' },
                { word: 'pull away', concept: 'è»Šè¼›é–‹å§‹ç§»å‹•', icon: 'ğŸš—', keyword: 'a vehicle starts moving', chinese: 'é§›é›¢' },
                { word: 'streak', concept: 'é¡è‰²æ¢ç´‹', icon: 'ğŸŒˆ', keyword: 'make long lines of color', chinese: 'æ¢ç´‹' },
                { word: 'shrug', concept: 'è³è‚©å‹•ä½œ', icon: 'ğŸ¤·', keyword: 'raise lower your shoulders', chinese: 'è³è‚©' },
                { word: 'attach', concept: 'é€£æ¥éˆæ¢', icon: 'ğŸ”—', keyword: 'to fasten or join one thing', chinese: 'é™„è‘—' },
                { word: 'ondal', concept: 'éŸ“åœ‹åœ°æš–ç³»çµ±', icon: 'â™¨ï¸', keyword: 'Korean heating system floor', chinese: 'éŸ“å¼åœ°æš–' },
                { word: 'radiator', concept: 'æš–æ°£æ©Ÿ', icon: 'ğŸ”¥', keyword: 'device heats a room steam', chinese: 'æ•£ç†±å™¨' },
                { word: 'enthusiastic', concept: 'èˆˆå¥®æ­¡å‘¼', icon: 'ğŸ¥³', keyword: 'feeling strong excitement', chinese: 'ç†±æƒ…çš„' },
                { word: 'fireplace', concept: 'å£çˆ', icon: 'ğŸ¡', keyword: 'brick stone space for fires', chinese: 'å£çˆ' },
                { word: 'cellar', concept: 'åœ°ä¸‹å®¤', icon: 'â¬‡ï¸', keyword: 'room built underground building', chinese: 'åœ°ä¸‹å®¤' },
                { word: 'peculiar', concept: 'å¥‡æ€ªçš„è‡‰', icon: 'ğŸ¤ª', keyword: 'odd strange unusual', chinese: 'å¥‡ç‰¹çš„' },
                { word: 'separate', concept: 'åˆ†é–‹/ä¿æŒè·é›¢', icon: 'âœ‚ï¸', keyword: 'to keep apart stop being together', chinese: 'åˆ†é–‹' },
                { word: 'disappointment', concept: 'å¤±æœ›çš„æ„Ÿè¦º', icon: 'ğŸ˜”', keyword: 'feeling of being disappointed', chinese: 'å¤±æœ›' },
                { word: 'homesick', concept: 'æ€å¿µå®¶äººå’Œå®¶', icon: 'ğŸ ', keyword: 'sad away from family and home', chinese: 'æ€é„‰çš„' },
                { word: 'insist', concept: 'å …æŒæŸäº‹', icon: 'ğŸ’ª', keyword: 'to be firm refuse to give up', chinese: 'å …æŒ' },
                { word: 'shingle', concept: 'å±‹é ‚è¦†è“‹ç‰©', icon: 'ğŸ§±', keyword: 'thin piece cover roof', chinese: 'æœ¨ç“¦' },
                { word: 'describe', concept: 'è¬›è¿°æˆ–å¯«ä¸‹', icon: 'âœï¸', keyword: 'to tell or write about something', chinese: 'æè¿°' },
                { word: 'maple', concept: 'æ¥“æ¨¹', icon: 'ğŸ', keyword: 'tree with notched leaves', chinese: 'æ¥“æ¨¹' },
                { word: 'parade', concept: 'å…¬å…±æ…¶ç¥éŠè¡Œ', icon: 'ğŸ‰', keyword: 'public celebration moving street', chinese: 'éŠè¡Œ' },
                { word: 'waltz', concept: 'é›™äººåœ“èˆ', icon: 'ğŸ’ƒ', keyword: 'to dance a round dance', chinese: 'è·³è¯çˆ¾èŒ²' },
                { word: 'curious', concept: 'æ¸´æœ›å­¸ç¿’æˆ–çŸ¥é“', icon: 'ğŸ§', keyword: 'eager to learn or know', chinese: 'å¥½å¥‡çš„' },
                { word: 'casserole', concept: 'å¯çƒ˜çƒ¤çš„æ·±ç›¤èœ', icon: 'ğŸ²', keyword: 'dish food baked and served', chinese: 'ç ‚é‹èœ' },
                { word: 'cantaloupe', concept: 'å“ˆå¯†ç“œ', icon: 'ğŸˆ', keyword: 'round melon orange flesh', chinese: 'å“ˆå¯†ç“œ' },
                { word: 'delicious', concept: 'å‘³é“æˆ–æ°£å‘³å¥½è', icon: 'ğŸ˜‹', keyword: 'having a pleasing taste or smell', chinese: 'ç¾å‘³çš„' },
                { word: 'giggle', concept: 'å­©å­æ°£çš„ç¬‘', icon: 'ğŸ˜‚', keyword: 'to laugh in a childlike way', chinese: 'å‚»ç¬‘' },
            ],
            13: [
                { word: 'bakery', concept: 'éºµåŒ…æˆ¿', icon: 'ğŸ', keyword: 'where bread cake cookies are sold', chinese: 'éºµåŒ…åº—' },
                { word: 'ingredient', concept: 'é£Ÿææ¸…å–®', icon: 'ğŸ“', keyword: 'things that are used to make food', chinese: 'åŸæ–™' },
                { word: 'batch', concept: 'ä¸€ç¾¤ç‰©å“', icon: 'ğŸ“¦', keyword: 'a group of things or people', chinese: 'ä¸€æ‰¹' },
                { word: 'mixture', concept: 'æ··åˆæ¶²é«”', icon: 'ğŸ§ª', keyword: 'combining two or more things', chinese: 'æ··åˆç‰©' },
                { word: 'dough', concept: 'éºµç³°', icon: 'ğŸ«“', keyword: 'mixture of flour water baked', chinese: 'éºµç³°' },
                { word: 'braided', concept: 'ç·¨ç¹”è¾®å­', icon: 'ğŸ‘©â€ğŸ¦±', keyword: 'to weave three or more parts', chinese: 'ç·¨æˆè¾®å­çš„' },
                { word: 'boil', concept: 'ç†±æ°´å†’æ³¡', icon: 'â™¨ï¸', keyword: 'become too hot bubbles are formed', chinese: 'æ²¸é¨°' },
                { word: 'jalapeÃ±o', concept: 'ç¶ è‰²è¾£æ¤’', icon: 'ğŸŒ¶ï¸', keyword: 'small green pepper very hot', chinese: 'å¢¨è¥¿å“¥è¾£æ¤’' },
                { word: 'international', concept: 'æ¶‰åŠå¤šåœ‹çš„', icon: 'ğŸŒ', keyword: 'having to do with two or more countries', chinese: 'åœ‹éš›çš„' },
                { word: 'culture', concept: 'èªè¨€é¢¨ä¿—è—è¡“', icon: 'ğŸ›ï¸', keyword: 'language customs ideas and art', chinese: 'æ–‡åŒ–' },
                { word: 'pick out', concept: 'æŒ‘é¸', icon: 'ğŸ‘†', keyword: 'to choose', chinese: 'æŒ‘é¸' },
                { word: 'treat', concept: 'ç¾å‘³çš„é£Ÿç‰©', icon: 'ğŸ¬', keyword: 'something that tastes good', chinese: 'ç¾å‘³' },
                { word: 'deal', concept: 'å”è­°/äº¤æ˜“', icon: 'ğŸ¤', keyword: 'an agreement between two people', chinese: 'å”è­°' },
                { word: 'knead', concept: 'æŒ‰å£“æ‰æéºµåœ˜', icon: 'ğŸ‘', keyword: 'to mix by pressing folding', chinese: 'æ‰æ' },
                { word: 'turnover', concept: 'æ°´æœé¤¡é¤…', icon: 'ğŸ¥§', keyword: 'small pie filled with fruit', chinese: 'é¤¡é¤…' },
                { word: 'spoon', concept: 'ç”¨æ¹¯åŒ™èˆ€å–', icon: 'ğŸ¥„', keyword: 'to pick up or move with a spoon', chinese: 'ç”¨æ¹¯åŒ™èˆ€' },
                { word: 'edge', concept: 'å…©é¢ç›¸äº¤çš„ç·š', icon: 'ğŸ“', keyword: 'a line where two surfaces meet', chinese: 'é‚Šç·£' },
                { word: 'flaky', concept: 'å°è–„ç‰‡ç‹€çš„', icon: 'ğŸ¥£', keyword: 'something in small flat thin pieces', chinese: 'è–„ç‰‡çš„' },
                { word: 'customer', concept: 'è³¼è²·ç”¢å“è€…', icon: 'ğŸ›ï¸', keyword: 'a person who buys products', chinese: 'é¡§å®¢' },
                { word: 'in charge', concept: 'è² è²¬æŸäº‹', icon: 'ğŸ’¼', keyword: 'to be responsible for something', chinese: 'è² è²¬' },
                { word: 'monkey man', concept: 'å·§å…‹åŠ›æ£’', icon: 'ğŸ«', keyword: 'a chocolate chip cookie bar', chinese: 'å·§å…‹åŠ›æ£’' },
                { word: 'especially', concept: 'æ›´ç”šæ–¼å¹³å¸¸', icon: 'ğŸŒŸ', keyword: 'more than usual', chinese: 'ç‰¹åˆ¥åœ°' },
                { word: 'extra', concept: 'å¤šé¤˜çš„', icon: 'â•', keyword: 'more than needed or expected', chinese: 'é¡å¤–çš„' },
                { word: 'yiddish', concept: 'æ±æ­çŒ¶å¤ªèª', icon: 'ğŸ“–', keyword: 'language spoken by eastern Jews', chinese: 'æ„ç¬¬ç·’èª' },
                { word: 'recipe', concept: 'è£½ä½œé£Ÿç‰©çš„æ­¥é©Ÿ', icon: 'ğŸ“œ', keyword: 'set of instructions for making something', chinese: 'é£Ÿè­œ' },
            ],
            14: [
                { word: 'connect', concept: 'é€£æ¥åœ¨ä¸€èµ·', icon: 'â†”ï¸', keyword: 'to join together', chinese: 'é€£æ¥' },
                { word: 'tray', concept: 'æ‰˜ç›¤', icon: 'ğŸ½ï¸', keyword: 'flat object carrying food and drinks', chinese: 'æ‰˜ç›¤' },
                { word: 'jewish', concept: 'çŒ¶å¤ªæ–‡åŒ–/å®—æ•™', icon: 'ğŸ•', keyword: 'having to do with Jews religion', chinese: 'çŒ¶å¤ªäººçš„' },
                { word: 'counter', concept: 'æ«ƒå°', icon: 'ğŸ›ï¸', keyword: 'a long high table', chinese: 'æ«ƒå°' },
                { word: 'slotted spoon', concept: 'æœ‰å­”çš„æ¹¯åŒ™', icon: 'ğŸ¥„', keyword: 'spoon has narrow holes liquid pass', chinese: 'æ¼å‹º' },
                { word: 'poppy', concept: 'ç½Œç²Ÿç±½è£é£¾', icon: 'ğŸª', keyword: 'seed used decorate flavor food', chinese: 'ç½Œç²Ÿ' },
                { word: 'sesame', concept: 'èŠéº»', icon: 'âšª', keyword: 'plant grown for its small oval seed', chinese: 'èŠéº»' },
                { word: 'smoked', concept: 'ç”¨ç…™ç‡»è£½', icon: 'ğŸ’¨', keyword: 'give a flavor using smoke', chinese: 'ç…™ç‡»çš„' },
                { word: 'pumpernickel', concept: 'é»‘éºµåŒ…', icon: 'ğŸ¥–', keyword: 'type of dark brown bread', chinese: 'é»‘éº¥éºµåŒ…' },
                { word: 'smear', concept: 'å¡—æŠ¹å‹•ä½œ', icon: 'ğŸ§ˆ', keyword: 'spreading something over a surface', chinese: 'å¡—æŠ¹' },
                { word: 'crinkle', concept: 'å¼„å‡ºè¨±å¤šçšºç´‹', icon: 'ğŸ§»', keyword: 'to make many wrinkles', chinese: 'å¼„çšº' },
                { word: 'chop', concept: 'åˆ‡èœå‹•ä½œ', icon: 'ğŸ”ª', keyword: 'to cut something into small pieces', chinese: 'åˆ‡ç¢' },
                { word: 'except', concept: 'ä¸åŒ…æ‹¬', icon: 'â–', keyword: 'not including', chinese: 'é™¤äº†' },
                { word: 'suddenly', concept: 'å¿«é€Ÿä¸”æ„æƒ³ä¸åˆ°', icon: 'âš¡', keyword: 'quickly and not expected', chinese: 'çªç„¶åœ°' },
                { word: 'lukewarm', concept: 'æº«æ°´', icon: 'ğŸŒ¡ï¸', keyword: 'only a little warm', chinese: 'å¾®æº«çš„' },
                { word: 'yeast', concept: 'éºµåŒ…ç™¼é…µ', icon: 'ğŸ', keyword: 'used make bread rise', chinese: 'é…µæ¯' },
                { word: 'stiff', concept: 'ç¡¬ä¸”é›£ä»¥å½æ›²', icon: 'ğŸ‹ï¸', keyword: 'hard and difficult to bend', chinese: 'åƒµç¡¬çš„' },
                { word: 'necessary', concept: 'éœ€è¦çš„', icon: 'âœ…', keyword: 'needed or required', chinese: 'å¿…éœ€çš„' },
                { word: 'joint', concept: 'å…©éƒ¨åˆ†é€£æ¥è™•', icon: 'ğŸ¦´', keyword: 'place where two parts are connected', chinese: 'é€£æ¥è™•' },
                { word: 'apart', concept: 'åˆ†é–‹/ç›¸è·', icon: 'â¡ï¸', keyword: 'separated or away from each other', chinese: 'åˆ†é–‹åœ°' },
                { word: 'rolling boil', concept: 'å¿«é€Ÿæ²¸é¨°', icon: 'ğŸ”¥', keyword: 'bubbles rise quickly to the top', chinese: 'æ»¾æ²¸' },
                { word: 'greased', concept: 'å¡—æ²¹', icon: 'ğŸ§´', keyword: 'to put oil on something', chinese: 'å¡—æ²¹çš„' },
                { word: 'malt', concept: 'éº¥èŠ½', icon: 'ğŸŒ¾', keyword: 'a type of grain', chinese: 'éº¥èŠ½' },
                { word: 'gluten', concept: 'å°éº¥ä¸­çš„è›‹ç™½è³ª', icon: 'ğŸ§ª', keyword: 'a protein found in wheat', chinese: 'éº©è³ª' },
                { word: 'parlor', concept: 'å‡ºå”®ç”¢å“çš„å•†åº—', icon: 'ğŸ›ï¸', keyword: 'a business sells a product', chinese: 'å•†åº—' },
            ],
            15: [
                { word: 'scallions', concept: 'è”¥æ®µ', icon: 'ğŸŒ¿', keyword: 'a spring onion', chinese: 'è”¥' },
                { word: 'dumplings', concept: 'é¤ƒå­', icon: 'ğŸ¥Ÿ', keyword: 'small savory ball meat seafood', chinese: 'é¤ƒå­' },
                { word: 'strands', concept: 'ç´°ç·š/é«®çµ²', icon: 'ğŸ§µ', keyword: 'long thin like hair or noodle', chinese: 'ç·š' },
                { word: 'seventy', concept: 'æ•¸å­— 70', icon: '7ï¸âƒ£0ï¸âƒ£', keyword: 'a number equals 7 sets of ten', chinese: 'ä¸ƒå' },
                { word: 'doorstep', concept: 'é–€éš', icon: 'ğŸšª', keyword: 'step leading up to the outer door', chinese: 'é–€éš' },
                { word: 'fragrant', concept: 'èŠ±é¦™', icon: 'ğŸŒ¸', keyword: 'having a pleasant or sweet smell', chinese: 'èŠ³é¦™çš„' },
                { word: 'peek', concept: 'å·çœ‹çœ¼ç›', icon: 'ğŸ‘€', keyword: 'look quickly', chinese: 'å·çœ‹' },
                { word: 'poem', concept: 'æœ‰éŸ»å¾‹çš„æ–‡å­—', icon: 'ğŸ“œ', keyword: 'writing expresses feelings with rhythm', chinese: 'è©©' },
                { word: 'brushwork', concept: 'ç•«å®¶ä½¿ç”¨ç•«ç­†çš„æ–¹å¼', icon: 'ğŸ–Œï¸', keyword: 'way a painter uses their brush', chinese: 'ç­†æ³•' },
                { word: 'damp', concept: 'æ¿•æ¯›å·¾', icon: 'ğŸ’¦', keyword: 'slightly wet', chinese: 'æ½®æ¿•çš„' },
                { word: 'ceramic', concept: 'é»åœŸç‡’è£½', icon: 'ğŸº', keyword: 'made from clay then baked until hard', chinese: 'é™¶ç“·çš„' },
                { word: 'millet', concept: 'ç”Ÿé•·åœ¨è²§ç˜ çš„ç©€ç‰©', icon: 'ğŸš', keyword: 'a cereal grown in warm countries', chinese: 'å°ç±³' },
                { word: 'silk', concept: 'å…‰æ»‘çš„è¼•è³ªç¹”ç‰©', icon: 'ğŸ§£', keyword: 'smooth light fabric from cocoons', chinese: 'çµ²ç¶¢' },
                { word: 'homeland', concept: 'æ•…é„‰', icon: 'ğŸŒ', keyword: 'a persons native land', chinese: 'æ•…é„‰' },
                { word: 'tears', concept: 'å“­æ³£çš„å½¢å¼', icon: 'ğŸ˜­', keyword: 'a form of crying', chinese: 'çœ¼æ·š' },
                { word: 'memory', concept: 'å¾éå»è¨˜ä½çš„äº‹', icon: 'ğŸ§ ', keyword: 'something remembered from the past', chinese: 'è¨˜æ†¶' },
                { word: 'kumquat', concept: 'é‡‘æ©˜', icon: 'ğŸŠ', keyword: 'small citrus fruit native to Asia', chinese: 'é‡‘æ©˜' },
                { word: 'blade', concept: 'æ¤ç‰©ç´°é•·è‘‰å­', icon: 'ğŸŒ¿', keyword: 'a single long narrow leaf of a plant', chinese: 'è‘‰ç‰‡' },
                { word: 'pebble', concept: 'å°çŸ³é ­', icon: 'ğŸª¨', keyword: 'small stone made smooth and round', chinese: 'éµåµçŸ³' },
                { word: 'rooftop', concept: 'å±‹é ‚å¤–è¡¨é¢', icon: 'ğŸ ', keyword: 'the outer surface of a buildings roof', chinese: 'å±‹é ‚' },
                { word: 'bamboo', concept: 'ç©ºå¿ƒè–ç†±å¸¶è‰', icon: 'ğŸ‹', keyword: 'tall tropical grass hollow stems', chinese: 'ç«¹å­' },
                { word: 'melody', concept: 'æ‚…è€³çš„éŸ³æ¨‚éŸ³èª¿', icon: 'ğŸ¶', keyword: 'series of musical tones pleasing sound', chinese: 'æ—‹å¾‹' },
                { word: 'poet', concept: 'å¯«è©©çš„äºº', icon: 'âœï¸', keyword: 'a person who write poems', chinese: 'è©©äºº' },
                { word: 'toss', concept: 'éš¨æ„è¼•æ‹‹', icon: 'ğŸ‘‹', keyword: 'to casually and lightly throw something', chinese: 'æ‹‹' },
                { word: 'melt', concept: 'å› ç†±è®Šæˆæ¶²é«”', icon: 'ğŸ’§', keyword: 'to make or become a liquid by heat', chinese: 'èåŒ–' },
            ],
            16: [
                { word: 'blink', concept: 'çœ¨çœ¼å‹•ä½œ', icon: 'ğŸ˜‰', keyword: 'shut and open eyes quickly', chinese: 'çœ¨çœ¼' },
                { word: 'airplane', concept: 'é£›æ©Ÿ', icon: 'ğŸ›«', keyword: 'vehicle designed for air travel', chinese: 'é£›æ©Ÿ' },
                { word: 'sunday', concept: 'æ˜ŸæœŸæ—¥', icon: 'â˜€ï¸', keyword: 'the day before Monday', chinese: 'æ˜ŸæœŸæ—¥' },
                { word: 'shoulder', concept: 'è‚©è†€', icon: 'ğŸ’ª', keyword: 'part of the body neck and arm', chinese: 'è‚©è†€' },
                { word: 'grandson', concept: 'å­«å­', icon: 'ğŸ‘¦', keyword: 'the son of ones daughter or son', chinese: 'å­«å­' },
                { word: 'clothes', concept: 'è¡£ç‰©', icon: 'ğŸ‘•', keyword: 'items worn to cover the body', chinese: 'è¡£æœ' },
                { word: 'ironed', concept: 'ç”¨ç†±é›»å™¨ç‡™å¹³', icon: 'ğŸ‘š', keyword: 'smooth with a hot appliance', chinese: 'ç†¨ç‡™çš„' },
                { word: 'apartment', concept: 'å…¬å¯“å¤§æ¨“', icon: 'ğŸ¢', keyword: 'a flat building with lots of rooms', chinese: 'å…¬å¯“' },
                { word: 'lead', concept: 'å‘å‰ç§»å‹•', icon: 'â¡ï¸', keyword: 'move forward', chinese: 'å¼•å°' },
                { word: 'gingerly', concept: 'å°å¿ƒç¿¼ç¿¼åœ°', icon: 'ğŸ¤«', keyword: 'in a a careful manner', chinese: 'å°å¿ƒç¿¼ç¿¼åœ°' },
                { word: 'banister', concept: 'æ¨“æ¢¯æ‰¶æ‰‹', icon: 'ğŸ¤š', keyword: 'the handrail at the side staircase', chinese: 'æ‰¶æ‰‹' },
                { word: 'glides', concept: 'æ»‘è¡Œ', icon: 'â›¸ï¸', keyword: 'moves with a smooth quiet motion', chinese: 'æ»‘å‹•' },
                { word: 'breathes', concept: 'å¸å…¥ç©ºæ°£åˆ°è‚º', icon: 'ğŸ˜®â€ğŸ’¨', keyword: 'take air in to the lungs', chinese: 'å‘¼å¸' },
                { word: 'padding', concept: 'åœ¨æ°´ä¸­ç§»å‹•', icon: 'ğŸŠ', keyword: 'move through the water', chinese: 'åœ¨æ°´ä¸­ç§»å‹•' },
                { word: 'ivy', concept: 'å¸¸æ˜¥è—¤', icon: 'ğŸŒ¿', keyword: 'shiny dark green five pointed leaf plant', chinese: 'å¸¸æ˜¥è—¤' },
                { word: 'dawn', concept: 'é»æ˜/ç ´æ›‰', icon: 'ğŸŒ…', keyword: 'time of day when light first appears', chinese: 'é»æ˜' },
                { word: 'twelve', concept: 'æ•¸å­— 12', icon: '1ï¸âƒ£2ï¸âƒ£', keyword: 'a number after eleven', chinese: 'åäºŒ' },
                { word: 'grandfather', concept: 'ç¥–çˆ¶/å¤–ç¥–çˆ¶', icon: 'ğŸ‘´', keyword: 'the father of ones father or mother', chinese: 'ç¥–çˆ¶' },
                { word: 'grandmother', concept: 'ç¥–æ¯/å¤–ç¥–æ¯', icon: 'ğŸ‘µ', keyword: 'the mother of ones father or mother', chinese: 'ç¥–æ¯' },
                { word: 'fifty', concept: 'æ•¸å­— 50', icon: '5ï¸âƒ£0ï¸âƒ£', keyword: 'a number equal of 5-tens', chinese: 'äº”å' },
                { word: 'starves', concept: 'éå¸¸é£¢é¤“', icon: 'ğŸ˜«', keyword: 'feels very hungry', chinese: 'æŒ¨é¤“' },
                { word: 'silence', concept: 'å®Œå…¨æ²’æœ‰è²éŸ³', icon: 'ğŸ”‡', keyword: 'complete absence of sound', chinese: 'å¯‚éœ' },
                { word: 'sidewalk', concept: 'äººè¡Œé“', icon: 'ğŸš¶', keyword: 'paved path of people to walk', chinese: 'äººè¡Œé“' },
                { word: 'native', concept: 'å‡ºç”Ÿåœ¨ç‰¹å®šåœ°æ–¹çš„äºº', icon: 'ğŸ‘¤', keyword: 'a person born in a specified country', chinese: 'æœ¬åœ°äºº' },
                { word: 'admire', concept: 'å°Šé‡æˆ–è®šè³', icon: 'ğŸ‘', keyword: 'respect or warm approval of something', chinese: 'æ¬½ä½©' },
            ],
            17: [
                { word: 'encourage', concept: 'åŠ æ²¹æ‰“æ°£', icon: 'ğŸ™Œ', keyword: 'to give hope help or support', chinese: 'é¼“å‹µ' },
                { word: 'native', concept: 'å‡ºç”Ÿåœ‹å®¶çš„', icon: 'ğŸ‘¤', keyword: 'relating to a persons country of birth', chinese: 'æœ¬åœ°çš„' },
                { word: 'settle', concept: 'å®šå±…æˆ¿å±‹', icon: 'ğŸ˜ï¸', keyword: 'to go and live in a place', chinese: 'å®šå±…' },
                { word: 'social', concept: 'èˆ‡ç¤¾æœƒç›¸é—œ', icon: 'ğŸ‘¥', keyword: 'relating to society and living together', chinese: 'ç¤¾æœƒçš„' },
                { word: 'local', concept: 'ç‰¹å®šåœ°é»çš„', icon: 'ğŸ“', keyword: 'having to do with a particular place', chinese: 'ç•¶åœ°çš„' },
                { word: 'expression', concept: 'èªªå‡ºæƒ³æ³•', icon: 'ğŸ’¬', keyword: 'saying or showing what you think', chinese: 'è¡¨é”' },
                { word: 'support', concept: 'åŒæ„æˆ–é¼“å‹µ', icon: 'ğŸ¤', keyword: 'to agree or encourage someone', chinese: 'æ”¯æŒ' },
                { word: 'essay', concept: 'é—œæ–¼ä¸»é¡Œçš„çŸ­æ–‡', icon: 'ğŸ“', keyword: 'a short piece of writing about a topic', chinese: 'æ–‡ç« ' },
                { word: 'factual', concept: 'çœŸå¯¦çš„/ä½¿ç”¨äº‹å¯¦', icon: 'âœ…', keyword: 'true using facts', chinese: 'äº‹å¯¦çš„' },
                { word: 'selection', concept: 'è¢«é¸ä¸­çš„æ±è¥¿', icon: 'â­', keyword: 'something that has been chosen', chinese: 'é¸æ“‡' },
                { word: 'immigrant', concept: 'ç§»å‹•äººç‰©', icon: 'ğŸŒ', keyword: 'person who moves to another country', chinese: 'ç§»æ°‘' },
                { word: 'promise', concept: 'æ‰¿è«¾æ‰‹å‹¢', icon: 'ğŸ¤', keyword: 'saying you will certainly do something', chinese: 'æ‰¿è«¾' },
                { word: 'include', concept: 'å°‡...ä½œç‚ºä¸€éƒ¨åˆ†', icon: 'â•', keyword: 'to have as a part of something', chinese: 'åŒ…æ‹¬' },
                { word: 'speak your mind', concept: 'èªªå‡ºæƒ³æ³•', icon: 'ğŸ—£ï¸', keyword: 'to say what a person thinks', chinese: 'æš¢æ‰€æ¬²è¨€' },
                { word: 'canvas', concept: 'åšå¯¦çš„å¸ƒæ–™', icon: 'ğŸ–¼ï¸', keyword: 'a type of heavy and strong cloth', chinese: 'å¸†å¸ƒ' },
                { word: 'community', concept: 'åŸé®/ç¾¤é«”', icon: 'ğŸ™ï¸', keyword: 'place where a group of people live', chinese: 'ç¤¾å€' },
                { word: 'celebration', concept: 'ç‰¹æ®Šç¤¾äº¤æ´»å‹•', icon: 'ğŸ¥³', keyword: 'a special social event celebrate', chinese: 'æ…¶ç¥æ´»å‹•' },
                { word: 'depict', concept: 'æç¹ªæˆ–æè¿°', icon: 'ğŸ¨', keyword: 'to show or describe something painting', chinese: 'æç¹ª' },
                { word: 'democracy', concept: 'äººæ°‘æŒæ¬Šçš„æ”¿åºœ', icon: 'ğŸ—³ï¸', keyword: 'government power is held by the people', chinese: 'æ°‘ä¸»' },
                { word: 'neighborhood', concept: 'å®¶å‘¨åœçš„åœ°å€', icon: 'ğŸ˜ï¸', keyword: 'area of a town around a persons home', chinese: 'é„°é‡Œ' },
                { word: 'provide', concept: 'æä¾›æ‰€éœ€', icon: 'ğŸ', keyword: 'to give what is needed', chinese: 'æä¾›' },
                { word: 'seamstress', concept: 'ä»¥ç¸«ç´‰ç‚ºæ¥­çš„å¥³æ€§', icon: 'ğŸ§µ', keyword: 'woman whose job is sewing making clothes', chinese: 'å¥³è£ç¸«å¸«' },
                { word: 'el salvador', concept: 'ä¸­ç¾æ´²åœ‹å®¶', icon: 'ğŸ—ºï¸', keyword: 'a country in Central America', chinese: 'è–©çˆ¾ç“¦å¤š' },
                { word: 'create', concept: 'å‰µé€ æ–°çš„äº‹ç‰©', icon: 'âœ¨', keyword: 'to make something new', chinese: 'å‰µé€ ' },
                { word: 'interpret', concept: 'è§£é‡‹å«ç¾©', icon: 'ğŸ§', keyword: 'to explain the meaning of something', chinese: 'è§£é‡‹' },
            ],
            18: [
                { word: 'sketch', concept: 'ç°¡å–®è‰åœ–', icon: 'âœï¸', keyword: 'simple quickly-made drawing not many details', chinese: 'ç´ æ' },
                { word: 'public', concept: 'é–‹æ”¾æ¨™èªŒ', icon: 'ğŸŒ', keyword: 'open and available to people', chinese: 'å…¬é–‹çš„' },
                { word: 'reach', concept: 'æŠµé”æ——å¹Ÿ', icon: 'ğŸ', keyword: 'to arrive at a place', chinese: 'æŠµé”' },
                { word: 'honor', concept: 'çç‰Œ/å°Šé‡', icon: 'ğŸ…', keyword: 'to show respect for someone', chinese: 'æ¦®è­½' },
                { word: 'downtown', concept: 'åŸå¸‚ä¸­å¿ƒ', icon: 'ğŸ¦', keyword: 'the main part of a city or town', chinese: 'å¸‚ä¸­å¿ƒ' },
                { word: 'billboard', concept: 'å»£å‘Šç‰Œ', icon: 'ğŸ“°', keyword: 'large board advertisements side of a road', chinese: 'å»£å‘Šç‰Œ' },
                { word: 'fashion', concept: 'ç”¨æ‰‹è£½ä½œ', icon: 'âœ‹', keyword: 'to make something using your hands', chinese: 'è£½ä½œ' },
                { word: 'extend', concept: 'å»¶é•·å°ºå¯¸', icon: 'ğŸ“', keyword: 'to make longer in size', chinese: 'å»¶ä¼¸' },
                { word: 'education', concept: 'ç•¢æ¥­å¸½', icon: 'ğŸ“', keyword: 'knowledge a person gets through learning', chinese: 'æ•™è‚²' },
                { word: 'graduate', concept: 'å®Œæˆå­¸æ¥­', icon: 'ğŸ“œ', keyword: 'to finish studying at high school or college', chinese: 'ç•¢æ¥­' },
                { word: 'inspire', concept: 'æ¿€å‹µäºº', icon: 'ğŸ’¡', keyword: 'make someone feel they want to do something', chinese: 'å•Ÿç™¼' },
                { word: 'central america', concept: 'ä¸­ç¾æ´²åœ°å€', icon: 'ğŸ—ºï¸', keyword: 'region North American joins South America', chinese: 'ä¸­ç¾æ´²' },
                { word: 'success', concept: 'çç›ƒ', icon: 'ğŸ†', keyword: 'achieving the results wanted or hoped for', chinese: 'æˆåŠŸ' },
                { word: 'symbolize', concept: 'ä½œç‚ºè±¡å¾µ', icon: 'ğŸ”‘', keyword: 'to be a symbol of something', chinese: 'è±¡å¾µ' },
                { word: 'pose', concept: 'ä¿æŒå§¿å‹¢', icon: 'ğŸ§', keyword: 'to hold a position as for a painting', chinese: 'æ“ºå§¿å‹¢' },
                { word: 'assistant', concept: 'å¹«å¿™åšå·¥ä½œçš„äºº', icon: 'ğŸ§‘â€ğŸ’¼', keyword: 'someone who helps someone else to do a job', chinese: 'åŠ©æ‰‹' },
                { word: 'theme', concept: 'ä¸»è¦è©±é¡Œ', icon: 'ğŸ“–', keyword: 'the main topic of a book movie talk', chinese: 'ä¸»é¡Œ' },
                { word: 'accomplish', concept: 'æˆåŠŸå®Œæˆ', icon: 'âœ”ï¸', keyword: 'to finish something successfully', chinese: 'å®Œæˆ' },
                { word: 'project', concept: 'å¤§ç¾¤ä½å®…', icon: 'ğŸ¢', keyword: 'a big group of homes built with public money', chinese: 'è¨ˆç•«' },
                { word: 'interesting', concept: 'å¸å¼•æ³¨æ„åŠ›', icon: 'ğŸ¤©', keyword: 'attracting your attention not boring', chinese: 'æœ‰è¶£çš„' },
                { word: 'originally', concept: 'ä¸€é–‹å§‹', icon: 'ğŸ•°ï¸', keyword: 'at first in the beginning', chinese: 'æœ€åˆ' },
                { word: 'political', concept: 'èˆ‡æ”¿åºœç›¸é—œ', icon: 'ğŸ›ï¸', keyword: 'having to do with politics or government', chinese: 'æ”¿æ²»çš„' },
                { word: 'belief', concept: 'ä½ ç›¸ä¿¡çš„äº‹æƒ…', icon: 'ğŸ™', keyword: 'something that you believe', chinese: 'ä¿¡ä»°' },
                { word: 'resident', concept: 'å±…ä½è€…', icon: 'ğŸ˜ï¸', keyword: 'a person who lives in a particular place', chinese: 'å±…æ°‘' },
                { word: 'amuse', concept: 'ä½¿äººæ­¡ç¬‘', icon: 'ğŸ¤£', keyword: 'to make someone laugh or smile', chinese: 'é€—æ¨‚' },
            ],
        };

        // --- å•†å“å’ŒåŸæ–™å®šç¾© ---

        // æˆå“åˆ—è¡¨ (Final Products)
        const products = [
            // L1 åŸºç¤å•†å“
            { id: 'fries', name: 'Fries', icon: 'ğŸŸ', basePrice: 40, requiredLevel: 1, type: 'product', recipe: { potato: 1, oil: 1, salt: 1 } },
            { id: 'cola', name: 'Cola', icon: 'ğŸ¥¤', basePrice: 30, requiredLevel: 1, type: 'product', recipe: { soda: 1, ice: 1 } },
            { id: 'burger', name: 'Burger', icon: 'ğŸ”', basePrice: 50, requiredLevel: 1, type: 'product', recipe: { bun: 2, beef: 1, lettuce: 1 } },
            { id: 'milkshake', name: 'Milkshake', icon: 'ğŸ¥›', basePrice: 35, requiredLevel: 1, type: 'product', recipe: { milk: 1, icecream_base: 1 } },
            
            // L2 è§£é–å•†å“ (1000 é‡‘å¹£)
            { id: 'nuggets', name: 'Nuggets', icon: 'ğŸ—', basePrice: 55, requiredLevel: 2, type: 'product', recipe: { chicken: 2, oil: 1, salt: 1 } },
            { id: 'hotdog', name: 'Hot Dog', icon: 'ğŸŒ­', basePrice: 60, requiredLevel: 2, type: 'product', recipe: { hotdog_bun: 1, sausage: 1, sauce: 1 } },
            
            // L3 è§£é–å•†å“ (3000 é‡‘å¹£)
            { id: 'pizza', name: 'Pizza', icon: 'ğŸ•', basePrice: 100, requiredLevel: 3, type: 'product', recipe: { dough: 1, cheese: 1, tomato_sauce: 1 } },
            { id: 'icecream', name: 'Ice Cream Sundae', icon: 'ğŸ¦', basePrice: 60, requiredLevel: 3, type: 'product', recipe: { icecream_base: 2, syrup: 1 } },

            // L4 è§£é–å•†å“ (6000 é‡‘å¹£)
            { id: 'salad', name: 'Salad', icon: 'ğŸ¥—', basePrice: 80, requiredLevel: 4, type: 'product', recipe: { lettuce: 2, dressing: 1, chicken: 1 } },
            { id: 'coffee', name: 'Coffee', icon: 'â˜•', basePrice: 45, requiredLevel: 4, type: 'product', recipe: { coffee_bean: 1, milk: 1 } },

            // L5 è§£é–å•†å“ (12000 é‡‘å¹£)
            { id: 'taco', name: 'Taco', icon: 'ğŸŒ®', basePrice: 150, requiredLevel: 5, type: 'product', recipe: { tortilla: 2, beef: 1, cheese: 1, sauce: 1 } },
            { id: 'sushi', name: 'Sushi Set', icon: 'ğŸ£', basePrice: 160, requiredLevel: 5, type: 'product', recipe: { rice: 2, fish: 1 } },
        ];

        // åŸæ–™åˆ—è¡¨ (Ingredients)
        const ingredients = [
            { id: 'potato', name: 'Potato', icon: 'ğŸ¥”', baseCost: 15, type: 'ingredient' },
            { id: 'oil', name: 'Frying Oil', icon: 'ğŸº', baseCost: 20, type: 'ingredient' },
            { id: 'salt', name: 'Salt', icon: 'ğŸ§‚', baseCost: 10, type: 'ingredient' },
            { id: 'soda', name: 'Soda Syrup', icon: 'ğŸ’§', baseCost: 30, type: 'ingredient' },
            { id: 'ice', name: 'Ice', icon: 'ğŸ§Š', baseCost: 5, type: 'ingredient' },
            { id: 'bun', name: 'Burger Bun', icon: 'ğŸ', baseCost: 25, type: 'ingredient' },
            { id: 'beef', name: 'Beef Patty', icon: 'ğŸ¥©', baseCost: 40, type: 'ingredient' },
            { id: 'lettuce', name: 'Lettuce', icon: 'ğŸ¥¬', baseCost: 15, type: 'ingredient' },
            { id: 'milk', name: 'Milk', icon: 'ğŸ¥›', baseCost: 20, type: 'ingredient' },
            { id: 'icecream_base', name: 'Ice Cream Base', icon: 'ğŸ¦', baseCost: 40, type: 'ingredient' },
            { id: 'chicken', name: 'Chicken Pieces', icon: 'ğŸ”', baseCost: 30, type: 'ingredient' },
            { id: 'hotdog_bun', name: 'Hot Dog Bun', icon: 'ğŸ¥–', baseCost: 35, type: 'ingredient' },
            { id: 'sausage', name: 'Sausage', icon: 'ğŸŒ­', baseCost: 35, type: 'ingredient' },
            { id: 'sauce', name: 'Sauce Packet', icon: 'ğŸ¥«', baseCost: 20, type: 'ingredient' },
            { id: 'dough', name: 'Pizza Dough', icon: 'ğŸ«“', baseCost: 50, type: 'ingredient' },
            { id: 'cheese', name: 'Cheese', icon: 'ğŸ§€', baseCost: 30, type: 'ingredient' },
            { id: 'tomato_sauce', name: 'Tomato Sauce', icon: 'ğŸ…', baseCost: 30, type: 'ingredient' },
            { id: 'syrup', name: 'Sundae Syrup', icon: 'ğŸ¯', baseCost: 40, type: 'ingredient' },
            { id: 'dressing', name: 'Salad Dressing', icon: 'ğŸ¾', baseCost: 30, type: 'ingredient' },
            { id: 'coffee_bean', name: 'Coffee Beans', icon: 'â˜•', baseCost: 50, type: 'ingredient' },
            { id: 'tortilla', name: 'Tortilla', icon: 'ğŸŒ®', baseCost: 50, type: 'ingredient' },
            { id: 'rice', name: 'Sushi Rice', icon: 'ğŸš', baseCost: 40, type: 'ingredient' },
            { id: 'fish', name: 'Fish Fillet', icon: 'ğŸŸ', baseCost: 60, type: 'ingredient' },
        ];
        
        // Combined list for easy lookup
        const allShopItems = [...products, ...ingredients];


        // --- Shop Facility Upgrade Data ---
        const facilityUpgrades = [
            { id: 'ad_board', name: 'Promo Board', icon: 'ğŸ“£', maxLevel: 3, description: 'Speeds up customer arrival', levels: [
                { cost: 50000, interval_reduction: 3000, display: '-2s' },
                { cost: 80000, interval_reduction: 5000, display: '-5s' },
                { cost: 120000, interval_reduction: 8000, display: '-8s' },
                { cost: 150000, interval_reduction: 15000, display: '-15s' },
            ]},
            { id: 'reg_boost', name: 'Pro Kitchen', icon: 'ğŸ”ª', maxLevel: 3, description: 'Permanently increases product selling price', levels: [
                { cost: 60000, price_multiplier: 0.1, display: '+10% Price' },
                { cost: 80000, price_multiplier: 0.25, display: '+25% Price' },
                { cost: 100000, price_multiplier: 0.5, display: '+50% Price' },
            ]},
        ];

        // --- Customer Feedback Data (In Traditional Chinese) ---
        const customerFeedback = {
            1: [
                "é‚„ä¸éŒ¯å•¦ï¼Œçµ¦å€‹è®šï¼",
                "å“è³ªå¯ä»¥æ¥å—ã€‚",
                "æ¯”æˆ‘æƒ³åƒä¸­å¥½ï¼Œæˆ‘è²·äº†ã€‚",
                "ç­‰äº†ä¸€ä¸‹ï¼Œä½†å•†å“é‚„è¡Œã€‚",
            ],
            2: [
                "åƒ¹æ ¼å…¬é“ï¼Œæœå‹™è¿…é€Ÿï¼Œä¸‹æ¬¡å†ä¾†ï¼",
                "å“‡ï¼é€™å¤ªæ£’äº†ï¼Œå®Œå…¨å€¼é€™äº›é‡‘å¹£ï¼",
                "é€™åšå¾—å¾ˆç”¨å¿ƒï¼æœ‰å®¶çš„å‘³é“ï¼",
                "æˆ‘å¾ˆæ»¿æ„ï¼ŒæœŸå¾…ä½ çš„åº—é‹ªèƒ½é€²æ›´å¤šè²¨ã€‚",
            ],
            3: [
                "L3è³£å®¶å°±æ˜¯ä¸ä¸€æ¨£ï¼å“è³ªå„ªè¶Šï¼Œæˆ‘æœƒæ¨è–¦çµ¦æœ‹å‹ï¼",
                "å¤ªæœ‰æ•ˆç‡äº†ï¼æˆ‘è¶•æ™‚é–“ï¼Œä½ å¹«å¤§å¿™äº†ï¼Œè¬è¬ï¼",
                "é€™æ˜¯ç›®å‰æˆ‘åœ¨é€™æ¢è¡—ä¸Šè²·éæœ€æ£’çš„é€Ÿé£Ÿï¼â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸",
                "ä½ çš„åº—é‹ªå¾ˆæœ‰æ½›åŠ›ï¼Œæ­å–œä½ å‡ç´šäº†ï¼",
            ],
            4: [
                "å“è³ªæ²’è©±èªªï¼Œé›–ç„¶åƒ¹æ ¼é«˜ï¼Œä½†æˆ‘ä»˜å¾—èµ·ï¼ç¹¼çºŒä¿æŒæ°´æº–ï¼",
                "é€™è·‘éŠæˆ²ç°¡ç›´é£›å¿«ï¼Œæˆ‘å¤ªæ»¿æ„äº†ï¼",
                "ä½ çš„ç¶“ç‡Ÿé ­è…¦çœŸæ˜¯é©šäººï¼Œç¹¼çºŒé€²è²¨å¥½æ±è¥¿å§ï¼",
                "äº¤æ˜“é †åˆ©ï¼ä½ æ­£åœ¨æˆç‚ºé€™æ¢è¡—ä¸Šæœ€æ£’çš„é€Ÿé£Ÿå¤§äº¨ï¼"
            ]
        };

        // --- Game State Variables (Centralized Declaration) ---
        let currentWeek = 11;
        let currentStage = 0;
        let currentView = 'game';
        let isProcessing = false;
        
        // Economy and Level
        let currentScore = 0; // Coins
        let playerLevel = 1;
        let playerInventory = {}; // { id: { quantity: N, isOnSale: true, cost: C } }
        const levelThresholds = [4000, 9000, 18000, 30000, 60000]; 
        const priceMultiplier = (level) => 1 + (level - 1) * 0.05;
        const costMultiplier = (level) => 1 + (level - 1) * 0.5;

        // Progress and State
        let completedStages = {}; 
        let activeGameState = {}; 
        let shopFacilities = {}; // { ad_board: 0, reg_boost: 0 }

        // Stage-Specific States
        let selectedConnectCard = null; // Stage 1
        let selectedMemoryCards = []; // Stage 2
        let matchedMemoryPairs = 0; // Stage 2
        let currentPuzzle = {}; // Stage 3
        let currentGuess = []; // Stage 3
        let stage3Words = []; // Stage 3
        let currentWordIndex = 0; // Stage 3
        const totalStage3Words = 10; 

        // Timer
        const BASE_CUSTOMER_INTERVAL = 40000; 
        let customerTimer = null; 

        // **SFX Setup (unchanged)**
        let correctSynth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "square" }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.2, release: 1 }
        }).toDestination();
        let wrongSynth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "sawtooth" }, envelope: { attack: 0.001, decay: 0.2, sustain: 0.01, release: 0.5 }
        }).toDestination();

        function playSFX(type) {
            Tone.start();
            if (type === 'correct') {
                correctSynth.triggerAttackRelease(["C5", "E5", "G5"], "8n");
            } else if (type === 'wrong') {
                wrongSynth.triggerAttackRelease(["C3", "B2"], "16n");
            } else if (type === 'click') {
                wrongSynth.triggerAttackRelease("G4", "32n");
            }
        }

        function stopBGM() {
            if (Tone.Transport.state !== 'stopped') {
                Tone.Transport.stop();
            }
        }

        function startBGM(stage) {
            stopBGM(); 
        }

        window.getCurrentWeek = () => currentWeek;

        // --- DOM Elements ---
        const gameBoard = document.getElementById('game-board');
        const messageBox = document.getElementById('message-box');
        const weekSelector = document.getElementById('week-selector');
        const scoreDisplay = document.getElementById('score-display');
        const levelDisplay = document.getElementById('level-display');
        const shopContent = document.getElementById('shop-content');
        const gameView = document.getElementById('game-view');
        const shopView = document.getElementById('shop-view');


        // --- Utility Functions ---

        // Fisher-Yates shuffle
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Display Score Increase/Decrease Feedback
        function showScoreFeedback(points) {
            const feedback = document.createElement('div');
            feedback.textContent = points > 0 ? `+${points}` : `${points}`;
            feedback.className = 'absolute font-extrabold text-2xl text-yellow-300 pointer-events-none transition-all duration-1000 opacity-100';
            
            const scoreRect = scoreDisplay.getBoundingClientRect();
            feedback.style.position = 'fixed'; 
            feedback.style.right = `${window.innerWidth - scoreRect.right - 20}px`;
            feedback.style.top = `${scoreRect.top + window.scrollY}px`;
            
            document.body.appendChild(feedback);
            
            // Animation trigger
            setTimeout(() => {
                feedback.style.transform = 'translateY(-50px)';
                feedback.style.opacity = '0';
            }, 50);
            
            // Remove element
            setTimeout(() => {
                feedback.remove();
            }, 1000);
        }
        
        // --- State Initialization and UI/Score/Economy Updates ---

        function updateLevel(newLevel) {
            playerLevel = newLevel;
            levelDisplay.textContent = `Level: ${playerLevel}`;
            messageBox.textContent = `Congrats! You reached Level ${playerLevel}! New items and facilities unlocked!`;
            playSFX('correct'); 
        }

        function checkLevelUp() {
            if (playerLevel <= levelThresholds.length) {
                const requiredCoins = levelThresholds[playerLevel - 1];
                if (currentScore >= requiredCoins) {
                    updateLevel(playerLevel + 1);
                    checkLevelUp();
                    return true;
                }
            }
            return false;
        }

        function updateScore(points) {
            currentScore += points;
            scoreDisplay.textContent = `Coins: ${currentScore}`;
            showScoreFeedback(points); 
            checkLevelUp();
            saveProgress();
        }

        function loadProgress() {
            const savedProgress = localStorage.getItem('vocabAdventureProgress');
            if (savedProgress) {
                const data = JSON.parse(savedProgress);
                completedStages = data.completedStages || {};
                currentScore = data.currentScore || 0;
                playerLevel = data.playerLevel || 1;
                playerInventory = data.playerInventory || {};
                activeGameState = data.activeGameState || {};
                shopFacilities = data.shopFacilities || {}; 
            }
            // Initialize facilities
            facilityUpgrades.forEach(f => {
                if (shopFacilities[f.id] === undefined) {
                    shopFacilities[f.id] = 0;
                }
            });
            scoreDisplay.textContent = `Coins: ${currentScore}`;
            levelDisplay.textContent = `Level: ${playerLevel}`;
        }

        function saveProgress() {
            const dataToSave = {
                completedStages: completedStages,
                currentScore: currentScore,
                playerLevel: playerLevel,
                playerInventory: playerInventory,
                activeGameState: activeGameState,
                shopFacilities: shopFacilities, 
            };
            localStorage.setItem('vocabAdventureProgress', JSON.stringify(dataToSave));
            updateUI();
        }
        
        // Reset All Game Progress
        window.resetGameProgress = function() {
            if (!confirm('ğŸš¨ Are you sure you want to reset all game progress, coins, and level? This action cannot be undone!')) {
                return;
            }

            localStorage.removeItem('vocabAdventureProgress');
            
            // Reset state variables
            currentScore = 0;
            playerLevel = 1;
            playerInventory = {};
            completedStages = {};
            activeGameState = {};
            shopFacilities = {}; 
            
            // Re-initialize facilities
            facilityUpgrades.forEach(f => { shopFacilities[f.id] = 0; });

            const allWeeks = Object.keys(vocabData).map(Number).sort((a, b) => a - b);
            currentWeek = allWeeks[0];
            currentStage = 0;
            
            stopCustomerTimer();
            stopBGM();
            
            messageBox.textContent = 'âœ… All progress cleared. Welcome back!';
            showView('game');
            selectWeek(currentWeek);
        }

        function saveActiveState(stateData) {
            if (!activeGameState[currentWeek]) activeGameState[currentWeek] = {};
            activeGameState[currentWeek][currentStage] = stateData;
            saveProgress();
        }

        function loadActiveState() {
            return activeGameState[currentWeek] ? activeGameState[currentWeek][currentStage] : null;
        }
        
        function setStageCompleted(week, stage) {
            if (!completedStages[week]) {
                completedStages[week] = [];
            }
            if (!completedStages[week].includes(stage)) {
                completedStages[week].push(stage);
                saveProgress();
            }
            // Clear temporary stage progress
            if (activeGameState[week] && activeGameState[week][stage]) {
                delete activeGameState[week][stage];
                saveProgress(); 
            }
        }
        
        function isStageCompleted(week, stage) {
            if (stage === 4) return false;
            return completedStages[week] && completedStages[week].includes(stage);
        }

        function isWeekCompleted(week) {
            const dataLength = 3; 
            return completedStages[week] && completedStages[week].length === dataLength;
        }

        function renderWeekSelector() {
            weekSelector.innerHTML = '';
            const allWeeks = Object.keys(vocabData).map(Number).sort((a, b) => a - b);
            
            allWeeks.forEach(week => {
                const isCompleted = isWeekCompleted(week);
                const button = document.createElement('button');
                button.className = `stage-button rounded-full text-sm transition-all ${week === currentWeek ? 'bg-red-500 border-red-700 shadow-red-700' : ''}`;
                button.textContent = `W${week} ${isCompleted ? 'âœ…' : ''}`;
                button.disabled = false; 
                
                button.onclick = () => selectWeek(week);
                weekSelector.appendChild(button);
            });
        }
        
        window.selectWeek = function(week) {
            currentWeek = week;
            currentStage = 0; 
            stopBGM();
            gameBoard.innerHTML = '<p class="text-center text-xl text-gray-500 pt-16">Please select a Stage above to start!</p>';
            messageBox.textContent = `Selected Week ${currentWeek}. Choose a stage.`;
            updateUI();
        }

        function updateUI() {
            renderWeekSelector();
            renderShop(); 

            if (currentWeek === 0) return;

            document.querySelectorAll('#stage-selector button').forEach(btn => btn.disabled = false);

            document.getElementById('stage1-button').textContent = isStageCompleted(currentWeek, 1) ? 'Stage 1: Picture Match âœ…' : 'Stage 1: Picture Match';
            document.getElementById('stage2-button').textContent = isStageCompleted(currentWeek, 2) ? 'Stage 2: Keyword Memory âœ…' : 'Stage 2: Keyword Memory';
            document.getElementById('stage3-button').textContent = isStageCompleted(currentWeek, 3) ? 'Stage 3: Spelling Challenge âœ…' : 'Stage 3: Spelling Challenge';
            document.getElementById('stage4-button').textContent = 'Stage 4: Handwriting Practice';
        }

        // --- View Switching ---
        window.showView = function(view) {
            currentView = view;
            if (view === 'game') {
                shopView.classList.add('hidden');
                gameView.classList.remove('hidden');
                stopCustomerTimer();
            } else if (view === 'shop') {
                gameView.classList.add('hidden');
                shopView.classList.remove('hidden');
                renderShop();
                startCustomerTimer();
            }
        }

        // --- Shop/Economy Logic ---
        function getFacilityPriceMultiplier() {
            const registerLevel = shopFacilities['reg_boost'] || 0;
            let totalMultiplier = 1.0;
            for (let i = 0; i < registerLevel; i++) {
                totalMultiplier += facilityUpgrades.find(f => f.id === 'reg_boost').levels[i].price_multiplier;
            }
            return totalMultiplier;
        }
    
        function getItemPrice(item) {
            const levelMultiplier = 0.5 + (playerLevel - 1) * 0.05;  
            const facilityMultiplier = 1;
            
            return Math.floor(item.basePrice * levelMultiplier * facilityMultiplier);
        }

        function getItemCost(item) {
            const levelMultiplier = 1 + (playerLevel - 1) * 0.4;  
            return Math.floor(item.baseCost * levelMultiplier);
        }
        
        function getCustomerInterval() {
            const adBoardLevel = shopFacilities['ad_board'] || 0;
            let totalReduction = 0;
            for (let i = 0; i < adBoardLevel; i++) {
                totalReduction += facilityUpgrades.find(f => f.id === 'ad_board').levels[i].interval_reduction;
            }
            return Math.max(5000, BASE_CUSTOMER_INTERVAL - totalReduction);
        }

        // Buy Facility
        window.buyFacility = function(facilityId) {
            const facility = facilityUpgrades.find(f => f.id === facilityId);
            const currentLevel = shopFacilities[facilityId] || 0;
            
            if (currentLevel >= facility.maxLevel) {
                messageBox.textContent = `${facility.name} is MAX Level!`;
                return;
            }

            const nextLevelData = facility.levels[currentLevel];
            const cost = nextLevelData.cost;

            if (currentScore >= cost) {
                updateScore(-cost);
                
                shopFacilities[facilityId] = currentLevel + 1;
                
                messageBox.textContent = `Facility Upgrade Success! ${facility.name} reached Level ${currentLevel + 1}!`;
                playSFX('correct');
                
                stopCustomerTimer();
                startCustomerTimer();
            } else {
                messageBox.textContent = `Insufficient Coins! Need ${cost} Coins.`;
                playSFX('wrong');
            }
            renderShop();
        }

        // Buy Ingredient (Item Type: ingredient)
        window.buyItem = function(itemId) {
            const item = allShopItems.find(i => i.id === itemId);
            const cost = getItemCost(item);
            
            if (item.type === 'product' && item.requiredLevel > playerLevel) {
                 messageBox.textContent = `Level too low! Need Level ${item.requiredLevel} to stock ${item.name}!`;
                 playSFX('wrong');
                 return;
            }

            if (currentScore >= cost) {
                updateScore(-cost);

                const isProduct = item.type === 'product';
                playerInventory[itemId] = playerInventory[itemId] || { quantity: 0, isOnSale: isProduct };
                playerInventory[itemId].quantity += 1;
                playerInventory[itemId].cost = item.baseCost; 
                messageBox.textContent = `Stocked 1 ${item.name}! Coins -${cost}.`;
                playSFX('correct');
            } else {
                messageBox.textContent = `Insufficient Coins! Cost: ${cost} Coins.`;
                playSFX('wrong');
            }
            renderShop();
        }
        
        // Craft Final Product
        window.craftItem = function(productId) {
            const product = products.find(p => p.id === productId);
            if (!product) return;

            const recipe = product.recipe;
            let hasEnoughIngredients = true;
            let missingIngredient = '';

            // 1. Check Recipe
            for (const ingredientId in recipe) {
                const required = recipe[ingredientId];
                const owned = (playerInventory[ingredientId] && playerInventory[ingredientId].quantity) || 0;
                if (owned < required) {
                    hasEnoughIngredients = false;
                    missingIngredient = ingredients.find(i => i.id === ingredientId)?.name || 'Unknown Ingredient';
                    break;
                }
            }

            if (hasEnoughIngredients) {
                // 2. Consume Ingredients
                for (const ingredientId in recipe) {
                    playerInventory[ingredientId].quantity -= recipe[ingredientId];
                    if (playerInventory[ingredientId].quantity <= 0) {
                        delete playerInventory[ingredientId]; 
                    }
                }

                // 3. Add to Product Stock (default to on sale)
                playerInventory[productId] = playerInventory[productId] || { quantity: 0, isOnSale: true };
                playerInventory[productId].quantity += 1;

                messageBox.textContent = `ğŸ‰ Crafted 1 ${product.name}! Ready for Sale!`;
                playSFX('correct');
                saveProgress();
            } else {
                // Determine ingredient name for feedback
                const ingredientNameForFeedback = ingredients.find(i => i.id === missingIngredient)?.name || 'Unknown Ingredient';
                const requiredAmount = recipe[Object.keys(recipe).find(id => id === missingIngredient)];

                messageBox.textContent = `âŒ Crafting failed! Missing Ingredient: ${ingredientNameForFeedback} (Need ${requiredAmount} units)`;
                playSFX('wrong');
            }
            renderShop();
        }

        // Toggle Sale Status (Products only)
        window.toggleSaleStatus = function(itemId) {
            if (playerInventory[itemId]) {
                const item = allShopItems.find(i => i.id === itemId); // **FIX: Use allShopItems to find the item type/name**
                
                if (item.type !== 'product') {
                    messageBox.textContent = `[${item.name}] is an ingredient and cannot be sold directly.`;
                    playSFX('wrong');
                    return;
                }

                if (playerInventory[itemId].isOnSale === undefined) {
                    playerInventory[itemId].isOnSale = true;
                }
                
                const currentStatus = playerInventory[itemId].isOnSale;
                playerInventory[itemId].isOnSale = !currentStatus;
                
                messageBox.textContent = `${playerInventory[itemId].isOnSale ? 'âœ… Listed for Sale' : 'âŒ Stored in Inventory'} ${item.name}!`; // **FIX: Use item.name**
                playSFX('click');
                saveProgress();
            }
        }

        function startCustomerTimer() {
            if (customerTimer) {
                clearInterval(customerTimer);
            }
            const interval = getCustomerInterval();
            const intervalSeconds = (interval / 1000).toFixed(1);
            messageBox.textContent = `Customers are waiting! (Next arrival in ~${intervalSeconds} seconds)`;
            customerTimer = setInterval(customerArrives, interval);
        }

        function stopCustomerTimer() {
            if (customerTimer) {
                clearInterval(customerTimer);
                customerTimer = null;
            }
        }

        function getCustomerReview(item, level) {
            const effectiveLevel = Math.min(Math.max(1, level), 4);
            const baseReviews = customerFeedback[effectiveLevel];
            const review = baseReviews[Math.floor(Math.random() * baseReviews.length)];
            
            // Revert item names in review to Chinese for better context flow
            const translatedItemName = vocabData[11].find(v => v.word.toLowerCase() === item.name.toLowerCase())?.chinese || item.name;
            
            return review.replace(/æ¼¢å ¡/g, item.name).replace(/å•†å“/g, item.name).replace(/æŠ«è–©/g, item.name); // Using item.name here is intentional to show English name in Chinese text.
        }

        function customerArrives() {
            const itemsOnSale = Object.entries(playerInventory)
                .filter(([id, data]) => data.quantity > 0 && data.isOnSale && products.some(p => p.id === id));
            
            if (itemsOnSale.length === 0) {
                messageBox.textContent = "ğŸ’¡ A customer arrived, but the shelves are empty! List some products for sale!";
                return;
            }

            const [itemId, inventoryData] = itemsOnSale[Math.floor(Math.random() * itemsOnSale.length)];
            const item = products.find(i => i.id === itemId);
            const price = getItemPrice(item);
            
            inventoryData.quantity -= 1;
            updateScore(price); 

            const review = getCustomerReview(item, playerLevel);
            
            messageBox.textContent = `ğŸ’° Customer bought 1 ${item.name}! You earned ${price} Coins! Feedback: "${review}"`;
            playSFX('correct');

            if (inventoryData.quantity === 0) {
                delete playerInventory[itemId]; 
            }
            renderShop();
        }

        // ========== Maintenance Cost System (Story Version) ==========

// æ¯ 5 åˆ†é˜æ‰£ä¸€æ¬¡ç¶­ä¿®è²»
const MAINTENANCE_INTERVAL = 300000;

// è¨­å‚™èˆ‡åŠ‡æƒ…ï¼ˆå£æ‰åŸå› ï¼‰
const FACILITIES = [
    { 
        name: "ç‚¸é‹ Fryer", 
        icon: "ğŸ³",
        reason: "å› ç‚ºé€£çºŒç‚¸äº†å¥½å¤šä»½è–¯æ¢ï¼Œçµæœéç†±åœæ©Ÿäº†ï¼"
    },
    { 
        name: "é£²æ–™æ©Ÿ Soda Machine", 
        icon: "ğŸ¥¤",
        reason: "å› ç‚ºè£¡é¢çš„ç³–æ¼¿å¤ªä¹…æ²’æ¸…ç†ï¼Œæ•´å€‹å µä½äº†ï¼"
    },
    { 
        name: "çƒ¤ç›¤ Grill", 
        icon: "ğŸ”",
        reason: "å› ç‚ºæ²¹å¢ç´¯ç©å¤ªå¤šï¼Œéœ€è¦å¤§æ¸…æ½”ï¼"
    },
    { 
        name: "é»å–®æ©Ÿ Order Terminal", 
        icon: "ğŸ–¥ï¸",
        reason: "å› ç‚ºç³»çµ±æ›´æ–°å¤±æ•—ï¼Œåªå‰©è—è‰²ç•«é¢äº†â€¦"
    },
    { 
        name: "å’–å•¡æ©Ÿ Coffee Brewer", 
        icon: "â˜•",
        reason: "å› ç‚ºç¼ºæ°´å¤ªä¹…æ•´å€‹ç•¶æ‰å•¦ï¼"
    }
];

// åŸºç¤ç¶­ä¿®è²»ï¼ˆå¯èª¿æ•´ï¼‰
const BASE_MAINTENANCE_COST = 40;

function applyMaintenanceCost() {
    // éš¨æ©ŸæŒ‘å£æ‰è¨­å‚™
    const facility = FACILITIES[Math.floor(Math.random() * FACILITIES.length)];

    // éš¨ç­‰ç´šæå‡ç¶­ä¿®è²»ï¼ˆç´„ 40â€“150ï¼‰
    const cost = Math.floor(BASE_MAINTENANCE_COST * (1 + playerLevel * 0.3));

    if (currentScore >= cost) {
        currentScore -= cost;
        updateScore(0);

        showMessage(`âš ï¸ ${facility.icon} ä½ çš„ ${facility.name} å£æ‰äº†ï¼${facility.reason} éœ€è¦ç¶­ä¿®ï¼š-${cost} coins`);
    } else {
        showMessage(`âš ï¸ ${facility.icon} ${facility.name} å£æ‰äº†ï¼Œä½†ä½ æ²’æœ‰è¶³å¤ çš„éŒ¢ï¼å¿«å»ç·´å–®å­—è³ºéŒ¢è£œä¸Šç¶­ä¿®è²»ï¼`);
    }
}

// å•Ÿå‹•ç¶­ä¿®å®šæ™‚å™¨
setInterval(applyMaintenanceCost, MAINTENANCE_INTERVAL);


        function renderShop() {
            let html = `
                <h2 class="text-3xl font-extrabold text-center text-yellow-300 mb-4">My Shop Status</h2>
                <div class="bg-gray-700 p-4 rounded-lg flex justify-around mb-6 text-lg font-bold">
                    <span>Level: <span class="text-blue-400">L${playerLevel}</span> (Next Lvl: ${playerLevel <= levelThresholds.length ? levelThresholds[playerLevel - 1] || 'MAX' : 'MAX'} Coins)</span>
                    <span>Coins: <span class="text-yellow-400">${currentScore} ğŸ’°</span></span>
                </div>
                
                <!-- Facility Upgrades -->
                <h3 class="text-2xl font-bold text-green-400 mb-3">Facility Upgrades (Permanent Boosts)</h3>
                <div id="facility-list" class="grid grid-cols-2 gap-4 mb-8">
            `;
            
            const facilityHtml = facilityUpgrades.map(f => {
                const currentLevel = shopFacilities[f.id] || 0;
                const isMax = currentLevel >= f.maxLevel;
                const nextLevel = isMax ? null : f.levels[currentLevel];
                const buttonDisabled = !nextLevel || currentScore < nextLevel.cost;
                const buttonText = isMax ? 'MAX Level' : `Upgrade (${nextLevel.cost} ğŸ’°)`;
                
                return `
                    <div class="facility-card p-3 rounded-lg border-2 flex flex-col justify-between">
                        <div class="flex items-center">
                            <span class="text-3xl mr-2">${f.icon}</span>
                            <p class="font-bold text-xl">${f.name} (Lvl ${currentLevel})</p>
                        </div>
                        <p class="text-sm text-gray-400 mt-2">${f.description}</p>
                        <p class="text-sm text-yellow-300 mt-1">Effect: ${isMax ? 'MAX REACHED' : nextLevel.display}</p>
                        <button onclick="buyFacility('${f.id}')" class="stage-button rounded-lg text-sm px-3 py-1 mt-2 
                            ${isMax ? 'facility-max-level cursor-default' : (buttonDisabled ? 'opacity-70 cursor-not-allowed bg-gray-500 border-gray-700' : 'facility-level-up shadow-red-800 hover:bg-red-300')}" 
                            ${buttonDisabled || isMax ? 'disabled' : ''}>
                            ${buttonText}
                        </button>
                    </div>
                `;
            }).join('');

            html += facilityHtml + `</div>`;


            // --- Product Crafting Area ---
            html += `<h3 class="text-2xl font-bold text-yellow-300 mb-3">Product Crafting (Consume Ingredients)</h3>
                <div id="craft-list" class="grid grid-cols-2 gap-4 mb-8">
            `;

            const craftHtml = products.map(product => {
                const recipe = product.recipe;
                let canCraft = true;
                let requiredList = [];

                for (const ingredientId in recipe) {
                    const required = recipe[ingredientId];
                    const owned = (playerInventory[ingredientId] && playerInventory[ingredientId].quantity) || 0;
                    
                    const ingredientItem = allShopItems.find(i => i.id === ingredientId);
                    const ingredientIcon = ingredientItem?.icon || 'â“';

                    requiredList.push(`${ingredientIcon} ${required} (${owned})`); 
                    if (owned < required) {
                        canCraft = false;
                    }
                }
                
                return `
                    <div class="crafting-card p-3 rounded-lg border-2 flex items-center justify-between">
                        <span class="text-3xl mr-3">${product.icon}</span>
                        <div class="flex-grow">
                            <p class="font-bold text-xl">${product.name}</p>
                            <p class="text-xs text-gray-300">Recipe: ${requiredList.join(', ')}</p>
                            <p class="text-xs text-green-400">Stock: ${(playerInventory[product.id] && playerInventory[product.id].quantity) || 0}</p>
                        </div>
                        <button onclick="craftItem('${product.id}')" class="stage-button rounded-lg text-sm px-3 py-1 
                            ${canCraft ? 'bg-green-500 border-green-700 shadow-green-700 hover:bg-green-400' : 'opacity-70 cursor-not-allowed bg-red-500 border-red-700'}" 
                            ${canCraft ? '' : 'disabled'}>
                            Craft (+1)
                        </button>
                    </div>
                `;
            }).join('');
            html += craftHtml + `</div>`;


            // Inventory Area (Only shows actual products for sale toggle)
            html += `<h3 class="text-2xl font-bold text-red-400 mb-3">Product Inventory (Sell/Store)</h3>
                <div id="inventory-list" class="grid grid-cols-2 gap-4 mb-8">
            `;

            const productInventoryHtml = products.map(item => {
                const inventory = playerInventory[item.id] || { quantity: 0, isOnSale: false };
                const quantity = inventory.quantity;
                const isOnSale = inventory.isOnSale;

                // Only show products that have been crafted or stocked at least once
                if (quantity === 0 && !isOnSale && !(item.id in playerInventory)) return ''; 

                const statusText = isOnSale ? 'âœ… Listed' : 'ğŸ“¦ Stored';
                const statusColor = isOnSale ? 'bg-green-500' : 'bg-gray-500';
                const buttonText = isOnSale ? 'Store' : 'Sell';
                
                return `
                    <div class="inventory-item-card p-3 rounded-lg border-2 flex items-center justify-between">
                        <span class="text-3xl mr-3">${item.icon}</span>
                        <div class="flex-grow">
                            <p class="font-bold text-xl flex items-center">
                                ${item.name} 
                                <span class="sale-status ml-2 ${statusColor} text-white">${statusText}</span>
                            </p>
                            <p class="text-sm text-gray-300">Stock: <span class="text-yellow-300">${quantity}</span></p>
                            <p class="text-xs text-gray-400">Current Price: <span class="text-green-400">${getItemPrice(item)} ğŸ’°</span></p>
                        </div>
                        <button onclick="toggleSaleStatus('${item.id}')" class="stage-button rounded-lg text-sm px-3 py-1 
                            ${quantity === 0 ? 'opacity-50 cursor-not-allowed bg-red-700 border-red-800' : 'bg-blue-600 border-blue-800 shadow-blue-800 hover:bg-blue-500'}" 
                            ${quantity === 0 ? 'disabled' : ''}>
                            ${buttonText}
                        </button>
                    </div>
                `;
            }).join('');

            html += (productInventoryHtml || '<p class="text-center text-gray-400 p-4">You have no crafted products ready for sale. Go craft some!</p>') + `</div>`;


            // Ingredient Stock Area
            html += `<h3 class="text-2xl font-bold text-blue-400 mb-3">Ingredient Stock (Purchase Raw Materials)</h3>
                <div id="buy-list" class="grid grid-cols-2 gap-4">
            `;

            const ingredientBuyHtml = ingredients.map(item => {
                const cost = getItemCost(item);
                const canBuy = currentScore >= cost;
                
                return `
                    <div class="shop-item-card p-3 rounded-lg border-2 flex items-center justify-between unlocked-item">
                        <span class="text-3xl mr-3">${item.icon}</span>
                        <div class="flex-grow">
                            <p class="font-bold text-xl">${item.name}</p>
                            <p class="text-sm text-gray-400">Current Stock: <span class="text-yellow-300">${(playerInventory[item.id] && playerInventory[item.id].quantity) || 0}</span></p>
                            <p class="text-xs text-gray-400">Cost: <span class="${canBuy ? 'text-yellow-300' : 'text-red-500'}">${cost} ğŸ’°</span></p>
                        </div>
                        <button onclick="buyItem('${item.id}')" class="stage-button rounded-lg text-sm px-3 py-1 
                            ${!canBuy ? 'opacity-70 cursor-not-allowed bg-gray-500 border-gray-700' : 'bg-green-500 border-green-700 shadow-green-700 hover:bg-green-400'}" 
                            ${canBuy ? '' : 'disabled'}>
                            Buy (+1)
                        </button>
                    </div>
                `;
            }).join('');

            html += ingredientBuyHtml + `</div>`;

            // Hidden Reset Button is already in place at the end of shop-content
            
            shopContent.innerHTML = html;
        }

        // --- Game Stages Logic (Unchanged) ---

        window.startGame = function(week, stage) {
            if (isProcessing) return;

            currentWeek = week;
            currentStage = stage;
            gameBoard.innerHTML = '';
            stopCustomerTimer();
            stopBGM(); 
            
            const wordList = vocabData[week];

            if (stage === 1) {
                initStage1(wordList);
            } else if (stage === 2) {
                initStage2(wordList);
            } else if (stage === 3) {
                initStage3(wordList);
            } else if (stage === 4) {
                 initStage4(wordList);
            }

            messageBox.textContent = `Week ${week} - Stage ${stage} Started! Good luck!`;
        };
        
        function initStage4(data) {
            const totalWords = data.length;
            
            // **é—œå¡å››æ˜¯ç„¡é™ç·´ç¿’æ¨¡å¼ï¼Œå¾å®Œæ•´æ¸…å–®ä¸­éš¨æ©Ÿé¸å–**
            const shuffledWords = shuffle([...data]); 
            let wordIndex = 0;
            
            const renderPractice = (wordData) => {
                const word = wordData.word.toLowerCase();
                
                gameBoard.className = 'flex flex-col items-center gap-6 p-4 bg-gray-900 rounded-lg';
                gameBoard.innerHTML = '';
                
                messageBox.textContent = `âœï¸ Stage 4: Handwriting Practice (Word ${wordIndex + 1} / ${totalWords})`;
                
                const hintArea = document.createElement('div');
                hintArea.className = 'text-center p-4 bg-gray-800 rounded-lg w-full max-w-lg shadow-xl';
                hintArea.innerHTML = `
                    <div class="text-4xl mb-2 font-bold text-red-300">${wordData.chinese}</div>
                    <div class="text-lg text-gray-300">${wordData.keyword}</div>
                `;
                gameBoard.appendChild(hintArea);

                const speakButton = document.createElement('button');
                speakButton.className = 'stage-button rounded-xl bg-green-600 border-green-800 shadow-green-800';
                speakButton.textContent = 'ğŸ”Š Read Word';
                speakButton.onclick = () => speakWord(wordData.word);
                gameBoard.appendChild(speakButton);
                
                const inputArea = document.createElement('div');
                inputArea.className = 'w-full max-w-lg mt-4';
                inputArea.innerHTML = `
                    <p class="text-left text-lg text-yellow-300 mb-2">Type the Word: </p>
                    <input id="handwriting-input" type="text" class="w-full p-3 text-2xl text-gray-900 rounded-lg border-2 border-yellow-500 lowercase" placeholder="Spell the word here...">
                    <button id="check-button" class="stage-button rounded-xl w-full mt-4">Check</button>
                `;
                gameBoard.appendChild(inputArea);

                document.getElementById('check-button').onclick = () => {
                    const inputElement = document.getElementById('handwriting-input');
                    const typedWord = inputElement.value.toLowerCase().trim();

                    if (typedWord === word) {
                        playSFX('correct');
                        updateScore(80);
                        messageBox.textContent = `âœ… Correct! Word '${word}' completed.`;
                        inputElement.classList.add('bg-green-200');
                        document.getElementById('check-button').disabled = true;

                        setTimeout(() => {
                            wordIndex = (wordIndex + 1) % totalWords; // å¾ªç’°åˆ°ä¸‹ä¸€å€‹å–®å­—
                            renderPractice(shuffledWords[wordIndex]);
                        }, 1500);
                    } else {
                        playSFX('wrong');
                        messageBox.textContent = `âŒ Incorrect! Try again.`;
                        inputElement.classList.add('bg-red-200');
                        setTimeout(() => {
                            inputElement.classList.remove('bg-red-200');
                        }, 500);
                    }
                };
            };
            
            renderPractice(shuffledWords[wordIndex]);
        }

        function initStage1(data) {
            const savedState = loadActiveState();
            const targetWordsCount = 8;
            
            let shuffledData;
            let matchedIds = [];
            
            if (savedState && savedState.matchedIds) {
                 shuffledData = savedState.shuffledData;
                 matchedIds = savedState.matchedIds;
            } else {
                 shuffledData = shuffle([...data]).slice(0, targetWordsCount);
            }

            const cards = shuffledData.map(item => ({ 
                word: item.word, 
                content: item.icon, 
                subContent: item.concept, 
                matchId: item.word 
            }));

            const wordCards = shuffle(cards.map(c => ({...c, type: 'word', content: c.word})));
            const conceptCards = shuffle(cards.map(c => ({...c, type: 'concept'})));

            gameBoard.className = 'grid grid-cols-2 gap-4 p-4 bg-gray-900 rounded-lg';
            
            const leftCol = document.createElement('div');
            leftCol.className = 'flex flex-col gap-4';
            const rightCol = document.createElement('div');
            rightCol.className = 'flex flex-col gap-4';

            wordCards.forEach(cardData => leftCol.appendChild(createConnectCard(cardData, handleStage1Click)));
            conceptCards.forEach(cardData => rightCol.appendChild(createConnectCard(cardData, handleStage1Click)));

            gameBoard.appendChild(leftCol);
            gameBoard.appendChild(rightCol);

            matchedIds.forEach(id => {
                document.querySelectorAll(`.connect-card[data-match-id="${id}"]`).forEach(card => {
                    card.classList.add('matched');
                });
            });
            
            const targetMatches = targetWordsCount;

            window.checkStage1Complete = function() {
                const currentMatchedCards = document.querySelectorAll('.connect-card.matched');
                const currentMatchedIds = [...new Set(Array.from(currentMatchedCards).map(c => c.dataset.matchId))]; 
                
                saveActiveState({ shuffledData: shuffledData, matchedIds: currentMatchedIds });


                 if (currentMatchedIds.length === targetMatches) {
                    setStageCompleted(currentWeek, 1);
                    messageBox.textContent = `ğŸ‰ Week ${currentWeek} Stage 1 Complete!`;
                    updateUI();
                 }
            }
        }

        function createConnectCard(cardData, clickHandler) {
            const card = document.createElement('div');
            card.className = 'card-container connect-card text-lg sm:text-xl transition-all';
            card.dataset.matchId = cardData.matchId;
            card.dataset.type = cardData.type;
            card.dataset.word = cardData.word;

            if (cardData.type === 'word') {
                card.innerHTML = `<span class="font-black">${cardData.content.toLowerCase()}</span>`;
            } else {
                card.innerHTML = `<span class="text-4xl">${cardData.content}</span><span class="text-xs text-gray-700 font-bold ml-2 hidden sm:inline">${cardData.subContent}</span>`;
                card.classList.add('justify-start', 'pl-4');
            }

            card.addEventListener('click', () => clickHandler(card));
            return card;
        }

        function handleStage1Click(card) {
            if (isProcessing || card.classList.contains('matched')) return;
            playSFX('click');
            
            if (selectedConnectCard) {
                const card1 = selectedConnectCard;
                const card2 = card;
                
                if (card1.dataset.type === card2.dataset.type || card1 === card2) {
                    card1.classList.remove('selected');
                    card.classList.add('selected'); 
                    selectedConnectCard = card;
                    return;
                }

                isProcessing = true;
                
                if (card1.dataset.matchId === card2.dataset.matchId) {
                    playSFX('correct');
                    updateScore(20); 
                    messageBox.textContent = `âš¡ï¸ Match Success: ${card1.dataset.matchId.toLowerCase()}! Coins +50!`;
                    
                    setTimeout(() => {
                        card1.classList.add('matched');
                        card2.classList.add('matched');
                        selectedConnectCard = null;
                        isProcessing = false;
                        window.checkStage1Complete(); 
                    }, 500);
                } else {
                    playSFX('wrong');
                    messageBox.textContent = 'âŒ Match Failed! Try again!';
                    setTimeout(() => {
                        card1.classList.remove('selected');
                        selectedConnectCard = null;
                        isProcessing = false;
                        window.checkStage1Complete();
                    }, 1000);
                }

            } else {
                card.classList.add('selected');
                selectedConnectCard = card;
            }
        }
        
        function initStage2(data) {
            const savedState = loadActiveState();
            const targetWordsCount = 8;
            
            let gameWords;
            let cardData;
            let matchedIds = [];
            
            if (savedState && savedState.cardData) {
                 gameWords = savedState.gameWords;
                 cardData = savedState.cardData;
                 matchedIds = savedState.matchedIds;
            } else {
                 gameWords = shuffle([...data]).slice(0, targetWordsCount); 
                 
                 const cards = gameWords.map(item => ({ word: item.word, keyword: item.keyword, matchId: item.word }));
                 cardData = [];
                 cards.forEach(item => {
                     cardData.push({ matchId: item.matchId, type: 'word', content: item.word });
                     cardData.push({ matchId: item.matchId, type: 'keyword', content: item.keyword });
                 });
                 cardData = shuffle(cardData); 
            }

            gameBoard.className = 'grid grid-cols-4 gap-4 p-4 bg-gray-900 rounded-lg';
            gameBoard.innerHTML = '';
            
            selectedMemoryCards = []; 
            isProcessing = false;

            cardData.forEach(item => {
                const card = createMemoryCard(item, handleStage2Click);
                if (matchedIds.includes(item.matchId)) {
                    card.classList.add('matched', 'flipped'); 
                }
                gameBoard.appendChild(card);
            });

            window.checkStage2Complete = function() {
                const matchedCards = document.querySelectorAll('.memory-card.matched');
                const matchedCount = matchedCards.length / 2;
                const currentMatchedIds = [...new Set(Array.from(matchedCards).map(c => c.dataset.matchId))];
                
                saveActiveState({ gameWords: gameWords, cardData: cardData, matchedIds: currentMatchedIds });

                if (matchedCount === targetWordsCount) {
                    setStageCompleted(currentWeek, 2);
                    messageBox.textContent = `ğŸ† Week ${currentWeek} Stage 2 Complete!`;
                    updateUI();
                }
            }
        }
        
        function createMemoryCard(cardData, clickHandler) {
            const card = document.createElement('div');
            card.className = 'memory-card card-container transition-all transform hover:scale-105';
            card.dataset.matchId = cardData.matchId;
            card.dataset.type = cardData.type;
            card.dataset.word = cardData.type === 'word' ? cardData.content : '';

            const cardBack = document.createElement('div');
            cardBack.className = 'memory-card-back rounded-xl text-3xl font-black';
            cardBack.textContent = '?'; 
            card.appendChild(cardBack);

            const cardContent = document.createElement('div');
            cardContent.className = 'memory-card-content p-2 text-red-800 font-black';
            cardContent.innerHTML = cardData.type === 'word' ? 
                `<span class="text-2xl sm:text-3xl">${cardData.content.toLowerCase()}</span>` : 
                `<span class="text-xs sm:text-sm text-center">${cardData.content.toLowerCase()}</span>`;
            card.appendChild(cardContent);

            card.addEventListener('click', () => clickHandler(card, cardData));
            return card;
        }

        function handleStage2Click(card, cardData) {
            if (isProcessing || card.classList.contains('flipped') || card.classList.contains('matched')) {
                return;
            }
            
            playSFX('click');

            card.classList.add('flipped');
            selectedMemoryCards.push(card);

            if (selectedMemoryCards.length === 2) {
                isProcessing = true;
                const [card1, card2] = selectedMemoryCards;
                const isMatch = card1.dataset.matchId === card2.dataset.matchId && card1.dataset.type !== card2.dataset.type;

                if (isMatch) {
                    playSFX('correct');
                    updateScore(60); 
                    messageBox.textContent = `â­ï¸ Perfect Match! ${card1.dataset.matchId.toLowerCase()}! Coins +100!`;
                    setTimeout(() => {
                        card1.classList.add('matched');
                        card2.classList.add('matched');
                        selectedMemoryCards = [];
                        isProcessing = false;
                        window.checkStage2Complete();
                    }, 500);
                } else {
                    playSFX('wrong');
                    messageBox.textContent = 'âŒ Match Failed! Focus!';
                    setTimeout(() => {
                        card1.classList.remove('flipped');
                        card2.classList.remove('flipped');
                        selectedMemoryCards = [];
                        isProcessing = false;
                        window.checkStage2Complete(); 
                    }, 1500);
                }
            }
        }
        
        function initStage3(data) {
            const savedState = loadActiveState();
            
            if (savedState && savedState.stage3Words) {
                stage3Words = savedState.stage3Words;
                currentWordIndex = savedState.currentWordIndex;
            } else {
                stage3Words = shuffle([...data]).slice(0, totalStage3Words);
                currentWordIndex = 0;
            }

            if (currentWordIndex >= totalStage3Words) {
                setStageCompleted(currentWeek, 3);
                return;
            }
            
            loadNextStage3Word();
        }

        function loadNextStage3Word() {
            if (currentWordIndex >= totalStage3Words) {
                setStageCompleted(currentWeek, 3);
                
                if (isWeekCompleted(currentWeek)) {
                    messageBox.textContent = `ğŸ† CONGRATS! You finished all challenges for Week ${currentWeek}! Next week unlocked!`;
                } else {
                    messageBox.textContent = `ğŸ‰ Week ${currentWeek} Stage 3 Complete!`;
                }
                updateUI();
                return;
            }
            
            const wordData = stage3Words[currentWordIndex];
            const word = wordData.word.toLowerCase();
            
            currentPuzzle = {
                word: word,
                targetLetters: word.split(''),
                jumbledLetters: shuffle(word.split('')),
                icon: wordData.icon,
                keyword: wordData.keyword
            };
            currentGuess = Array(word.length).fill(null);

            gameBoard.className = 'flex flex-col items-center gap-6 p-4 bg-gray-900 rounded-lg';
            gameBoard.innerHTML = '';
            isProcessing = false; 

            saveActiveState({ stage3Words: stage3Words, currentWordIndex: currentWordIndex });
            
            messageBox.textContent = `ğŸ¯ Stage 3: Word ${currentWordIndex + 1} / ${totalStage3Words}: Spell the word!`;
            speakWord(word); 

            const hintArea = document.createElement('div');
            hintArea.className = 'text-center p-4 bg-gray-800 rounded-lg w-full max-w-lg shadow-xl';
            hintArea.innerHTML = `
                <div class="text-6xl mb-2">${wordData.chinese} ${currentPuzzle.icon}</div>
                <div class="text-xl font-bold text-yellow-300">Hint (Keyword):</div>
                <div class="text-lg text-gray-300">${currentPuzzle.keyword.toLowerCase()}</div>
            `;
            gameBoard.appendChild(hintArea);

            const answerArea = document.createElement('div');
            answerArea.id = 'answer-area';
            answerArea.className = 'flex justify-center mb-6';
            currentPuzzle.targetLetters.forEach((_, index) => {
                const slot = document.createElement('div');
                slot.className = 'letter-slot card-container m-1';
                slot.dataset.index = index;
                slot.addEventListener('click', () => handleSlotClick(index)); 
                answerArea.appendChild(slot);
            });
            gameBoard.appendChild(answerArea);
            
            const letterArea = document.createElement('div');
            letterArea.id = 'letter-area';
            letterArea.className = 'flex flex-wrap justify-center max-w-lg';
            currentPuzzle.jumbledLetters.forEach((letter, index) => {
                const block = document.createElement('div');
                block.className = 'card-container letter-block jumbled cursor-pointer';
                block.textContent = letter;
                block.dataset.originalIndex = index;
                block.dataset.inUse = 'false'; 
                block.addEventListener('click', () => handleLetterClick(block, letter, index));
                letterArea.appendChild(block);
            });
            gameBoard.appendChild(letterArea);
        }

        function handleLetterClick(block, letter, originalIndex) {
            if (isProcessing || block.dataset.inUse === 'true') return;
            playSFX('click');

            const emptySlotIndex = currentGuess.findIndex(val => val === null);
            if (emptySlotIndex !== -1) {
                currentGuess[emptySlotIndex] = { letter: letter, originalIndex: originalIndex };
                
                const slotElement = document.querySelector(`#answer-area .letter-slot[data-index="${emptySlotIndex}"]`);
                slotElement.textContent = letter;
                block.dataset.inUse = 'true';
                block.classList.remove('jumbled', 'cursor-pointer');
                block.classList.add('correct');
                
                if (currentGuess.every(val => val !== null)) {
                    checkSpelling();
                }
            }
        }
        
        function handleSlotClick(slotIndex) {
            if (isProcessing) return;
            const guess = currentGuess[slotIndex];
            if (!guess) return; 

            playSFX('click');
            
            const originalBlock = document.querySelector(`#letter-area .letter-block[data-original-index="${guess.originalIndex}"]`);
            
            document.querySelector(`#answer-area .letter-slot[data-index="${slotIndex}"]`).textContent = '';
            currentGuess[slotIndex] = null;

            originalBlock.dataset.inUse = 'false';
            originalBlock.classList.add('jumbled', 'cursor-pointer');
            originalBlock.classList.remove('correct');
            originalBlock.addEventListener('click', () => handleLetterClick(originalBlock, guess.letter, guess.originalIndex));
        }

        function checkSpelling() {
            isProcessing = true;
            const userWord = currentGuess.map(g => g.letter).join('');
            const correctWord = currentPuzzle.word;

            if (userWord === correctWord) {
                playSFX('correct');
                updateScore(40); 
                messageBox.textContent = `ğŸ‰ Correct! Word: ${correctWord.toLowerCase()}! Coins +200! (Next word in 2s)`;
                
                document.querySelectorAll('#answer-area .letter-slot').forEach(slot => {
                    slot.classList.add('bg-green-600', 'text-white', 'border-green-800');
                    slot.classList.remove('border-gray-500');
                });

                setTimeout(() => {
                    currentWordIndex++; 
                    isProcessing = false;
                    loadNextStage3Word(); 
                }, 2000);
            } else {
                playSFX('wrong');
                messageBox.textContent = `âŒ Incorrect Spelling! Reassemble the letters.`;
                
                document.getElementById('answer-area').querySelectorAll('.letter-slot').forEach(slot => {
                    if(slot.textContent) slot.classList.add('error');
                });

                setTimeout(() => {
                    document.getElementById('answer-area').querySelectorAll('.letter-slot').forEach(slot => {
                        slot.textContent = '';
                        slot.classList.remove('error'); 
                    });
                    
                    document.getElementById('letter-area').querySelectorAll('.letter-block').forEach(block => {
                        if (block.dataset.inUse === 'true') {
                            const letter = block.textContent;
                            const originalIndex = block.dataset.originalIndex;
                            block.dataset.inUse = 'false';
                            block.classList.add('jumbled', 'cursor-pointer');
                            block.classList.remove('correct');
                            block.addEventListener('click', () => handleLetterClick(block, letter, originalIndex));
                        }
                    });
                    currentGuess = Array(currentPuzzle.word.length).fill(null);
                    isProcessing = false;
                }, 1500);
            }
        }

        // --- Page Startup ---
        window.onload = () => {
            loadProgress();
            
            const allWeeks = Object.keys(vocabData).map(Number).sort((a, b) => a - b);
            currentWeek = allWeeks[0];

            selectWeek(currentWeek); 
            // **FIX: Add event listener to save progress before unload**
            window.addEventListener('beforeunload', () => {
                // Ensure active game state is saved before the window closes
                if (currentStage === 1) window.checkStage1Complete();
                if (currentStage === 2) window.checkStage2Complete();
                if (currentStage === 3) saveActiveState({ stage3Words: stage3Words, currentWordIndex: currentWordIndex });
            });
        };

    </script>
</body>
</html>
